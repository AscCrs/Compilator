options {
    LOOKAHEAD = 1;
}

PARSER_BEGIN(linkersOptimizado)

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter; 
import java.util.Collections;

class linkersOptimizado {

    // Tabla de errores
    static ArrayList<String> tabla = linkersOptimizadoTokenManager.tablaErrores;
    static Map<String, String> declaredVariables = new HashMap<String, String>();

    // Lista para almacenar el TAC generado
    static ArrayList<TAC> intermedia = new ArrayList<TAC>();
    static int tempVarCounter = 0; // contador de variables temporales actuales
    static int labelCounter = 0; // contador de etiquetas actuales
    static ArrayList<String> casos = new ArrayList<>();
    static ArrayList<String> partesIF = new ArrayList<>();
    static ArrayList<String> contenidoIF = new ArrayList<>();
    static int countLines = 0;
    static int contadorCondiciones = 0;
    static int cases = 0;

    public static void main(String[] args) {
        try {
            linkersOptimizado link = new linkersOptimizado(System.in);
            link.Programalink();

            if (!link.tabla.isEmpty()) {
                System.out.println("\u001B[31m\nErrores encontrados:\n\u001B[0m");
                for (String error : link.tabla) {
                    System.out.println(error);
                }
            } else {
                System.out.println("\u001B[32mAnálisis exitoso\u001B[0m");

                // Generar el archivo de codigo intermedio
                String outputFileName = "Intermedio_Optimizado.txt";
                PrintWriter writer = null;
                try {
                    writer = new PrintWriter(new FileWriter(outputFileName));
                    for (TAC i : intermedia) {
                        writer.println(i);
                    }
                    System.out.println("\nEl codigo intermedio generado ha sido guardado en el archivo: " + outputFileName);

                } catch (IOException e) {
                    System.out.println("Error al escribir el codigo intermedio en el archivo: " + e.getMessage());
                } finally {
                    if (writer != null) {
                        writer.close();
                    }
                }
            }

        } catch (ParseException e) {
            System.out.println("Error de Análisis -> " + e.getMessage());
        }
    }

    static void checkAndAddVariable(Token id, String type, int line, int column) {
        if (declaredVariables.containsKey(id.image)) {
            tabla.add("Error Semántico -> Variable repetida: " + id.image + " en línea " + line + ", columna " + column);
        } else {
            declaredVariables.put(id.image, type);
        }
    }

    public static <T> void cambiarPosicion(ArrayList<T> lista, int posicionInicial, int posicionNueva) {
        T elementoTemporal = lista.get(posicionInicial); // Almacena el elemento en la posición inicial
        lista.set(posicionInicial, lista.get(posicionNueva)); // Coloca el elemento de la posición nueva en la posición inicial
        lista.set(posicionNueva, elementoTemporal); // Coloca el elemento temporal en la posición nueva
    }

    public static <T> ArrayList<T> moverUltimosNAntesDePosicion(ArrayList<T> lista, int n, int posicionDestino) {
        int size = lista.size();

        // Validaciones
        if (n <= 0 || n > size) {
            throw new IllegalArgumentException("n debe estar entre 1 y el tamaño de la lista");
        }
        if (posicionDestino < 0 || posicionDestino > size - n) {
            throw new IllegalArgumentException("La posición de destino debe estar dentro de los límites válidos");
        }

        // Divide la lista en tres partes: antes de la posición de destino, los últimos n elementos, y el resto
        ArrayList<T> parteInicial = new ArrayList<>(lista.subList(0, posicionDestino));
        ArrayList<T> ultimosN = new ArrayList<>(lista.subList(size - n, size));
        ArrayList<T> parteCentral = new ArrayList<>(lista.subList(posicionDestino, size - n));

        // Une las partes en el nuevo orden: parte inicial + últimos n + parte central
        parteInicial.addAll(ultimosN);
        parteInicial.addAll(parteCentral);

        return parteInicial;
    }

    public static boolean comprobarDuplicados(ArrayList<String> lista, int posicionInicio) {
        // Validar la posición de inicio
        if (posicionInicio < 0 || posicionInicio >= lista.size()) {
            throw new IllegalArgumentException("La posición de inicio debe estar dentro de los límites de la lista");
        }

        // Iterar sobre cada elemento en la lista
        for (int i = posicionInicio; i < lista.size(); i++) {
            String elementoActual = lista.get(i);

            // Comprobar duplicados a partir de la posición de inicio
            for (int j = i + 1; j < lista.size(); j++) {
                if (elementoActual.equals(lista.get(j))) {
                    return true; // Si se encuentra un duplicado, retorna true
                }
            }
        }
        return false; // Si no se encuentran duplicados, retorna false
    }

    

    // Clase para el objeto de representacion intermedia
    static class TAC {
        private String operator;
        private String operand1;
        private String operand2;
        private String result;

        public TAC() { }

        // Constructor para operaciones binarias (+, -, *, /)
        public TAC(String operator, String operand1, String operand2, String result) {
            this.operator = operator;
            this.operand1 = operand1;
            this.operand2 = operand2;
            this.result = result;
        }

        // Constructor para operaciones de Asignacion 
        public TAC(String operator, String operand1, String result) {
            this(operator, operand1, null,result); // Se llama al primer constructor por una operacion unaria
        }

        // Constructor para operaciones de salto o etiquetado 
        public TAC(String operator, String result) {
            this(operator, null, null, result); // Operaciones sin operandos
        }

        // getters

        public String getOperator() {
            return this.operator;
        }

        public String getOperand1() {
            return this.operand1;
        }

        public String getOperand2() {
            return this.operand2;
        }

        public String getResult() {
            return this.result;
        }

        @Override
        public String toString() {
            if (this.operand2 != null) { // Es una operacion binaria
                return this.result + " = " + this.operand1 + " " + this.operator + " " + this.operand2;
            } else if (this.operand1 != null) { 
                return this.result + " " + this.operator + " " + this.operand1;
            } else { // Operaciones unarias
                return this.operator + " " + this.result;
            }
        }
    }

    // Clase para representar el resultado de una expresión
    static class ExpressionResult {
        String type;
        String place;

        public ExpressionResult(String type, String place) {
            this.type = type;
            this.place = place;
        }
    }

    // Procedimiento para generar variables temporales 
    static String newTemp() {
        return "t" + (tempVarCounter++);
    }

    // Método para generar el etiquetado
    static String newLabel() {
        return "L" + (labelCounter++) + " : ";
    }

    static String newLabelNoPoint(){
        return "L" + (labelCounter++);
    }

    static class Parameter {
        String type;
        String name;
    
        public Parameter(String type, String name) {
            this.type = type;
            this.name = name;
        }

        public Parameter() {

        }
    }

}

PARSER_END(linkersOptimizado)

TOKEN_MGR_DECLS : {
    static ArrayList<String> tablaErrores = new ArrayList<String>();

    public void LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {
        String errorMessage = "Error Léxico -> Línea: " + errorLine + ", Columna: " + errorColumn + ", Descripción: ";
        if (EOFSeen) {
            errorMessage += "<EOF> encontrado, pero esperaba más caracteres.";
        } else {
            errorMessage += "\"" + curChar + "\" encontrado, pero esperaba más caracteres.";
        }
        linkersOptimizado.tabla.add(errorMessage); // Corregido para apuntar a 'tabla'
    }
}

TOKEN: {//PALABRAS RESERVADAS
    <ReservadaInicio: "INICIAR">
    | <Lectura: "Leer">
    | <Escritura: "Escribir">
    | <CondicionalIf: "if">
    | <CondicionalElse: "else"> 
    | <CondicionalIfthen: "ifthen">
    | <CondicionalSwitch: "Switch">
    | <CicloWhile: "While">
    | <CicloFor: "For">
    | <Default: "Default">
    | <Caso: "Caso">
    | <Break: "Break">
    | <VERDADERO: "Verdadero">
    | <FALSO: "Falso">
    | <PUBLICO: "Publico">
    | <PRIVADO: "Privado">
    | <NoRetorno: "NoRetorno">
    | <Start: "Start">
    | <End: "End">
    | <Funcion: "Funcion">
    | <Retorno: "Retorno">
    | <LlamarFuncion: "call">
}

TOKEN: {// TIPOS DE DATO
    <TipoDatoEntero: "Entero">
    | <TipoDatoDecimal: "Decimal">
    | <TipoDatoBooleano: "boolean">
    | <TipoDatoCadena: "Cadena">
    | <TIpoDatoCaracter: "Caracter">
}

TOKEN: { //CARACTERES
    <LlaveAbre: "{">
    | <LlaveCierra: "}">
    | <ParentesisAbre: "(">
    | <ParentesisCierra: ")">
    | <DelimitadorLineaDeCodigo: ";">
    | <DelimitadorCasoSwitch: ":">
    | <CorcheteAbre: "[">
    | <CorcheteCierra: "]">
    | <Coma: ",">
}

TOKEN: {// OPERADORES ARITMETICOS
     <OperacionSuma: "+">
    | <OperacionResta: "-">
    | <OperacionMultiplicacion: "*">
    | <OperacionDivision: "/">
    | <OperacionResiduo: "%">
}

TOKEN: {// OPERADORES RELACIONALES
    <Asignacion: "=">
    | <OperacionMayorQue: ">">
    | <OperacionMenorQue: "<">
    | <OperacionMenorOIgualQue: "<=">
    | <OperacionMayorOIgualQue: ">=">
    | <OperacionIgualdad: "==">
    | <OperacionDesigualdad: "!=">
}

TOKEN: {// OPERADORES LOGICOS
    <OperacionAnd: "&">
    | <OperacionOr: "|">
    | <OperacionNot: "!">
}

TOKEN: {
    <CADENA: "\""(~["\""])*"\"">
    | <IDENTIFICADOR: (<LETRA>)+ (<LETRA>|<NUMERO>)* >
    | <NUMERO_FLOTANTE: (["0"-"9"])+"."(["0"-"9"])+>
    | <NUMERO: (["0"-"9"])+>
    | <LETRA: (["A"-"Z","a"-"z","á","é","í","ó","ú"])+>
}

SKIP: {
    " " | "\r" | "\t" | "\n" 
}

SPECIAL_TOKEN: {
    < ANYTHING : ~[] > // Esto capturará cualquier token no definido
    {
        linkersOptimizado.tabla.add("Error Léxico -> Línea: " + input_stream.getEndLine() + ", Columna: " + input_stream.getEndColumn() + ", Token no reconocido.");
    }
}

void Programalink() : {}{
    try {
        (
            try{<ReservadaInicio> }catch(ParseException e){tabla.add("Error de Sintaxis -> " + e.getMessage());}
            try{<LlaveAbre> }catch(ParseException e){tabla.add("Error de Sintaxis -> " + e.getMessage());}

            (sentencias())*

            try{<LlaveCierra> }catch(ParseException e){tabla.add("Error de Sintaxis -> " + e.getMessage());} )

            (procedimiento())*

            (funcion())*
    <EOF>
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != EOF);

        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

void sentencias() : {} {
    declararVariables()
    | asignacion()
    | entrada()
    | salida()
    | condicionalIf()
    | condicionalIfthen()
    | cicloFor()
    | cicloWhile()
    | condicionalSwitch()
    | llamadaFuncion()
    {countLines++;}
} 


void verificarExistenciaVariable(Token token) : {} {
    {
        if (!linkersOptimizado.declaredVariables.containsKey(token.image)) {
            linkersOptimizado.tabla.add("Error Semántico -> Variable no declarada: " + token.image + " en línea " + token.beginLine + ", columna " + token.beginColumn);
        }
    }
}

/**
 * Verifica la existencia de un token y obtiene su tipo.
 *
 * @param token El token que se va a verificar.
 * @return El tipo del token si existe, de lo contrario, un valor que indique que no existe.
 * @throws SomeException Si ocurre un error durante la verificación.
 */
String verificarExistenciaYObtenerTipo(Token token) : {
    String tipo;
} {
    {
        if (token.kind == linkersOptimizadoConstants.IDENTIFICADOR) {
            if (linkersOptimizado.declaredVariables.containsKey(token.image)) {
                tipo = linkersOptimizado.declaredVariables.get(token.image);
            } else {
                linkersOptimizado.tabla.add("Error Semántico -> Variable no declarada: " + token.image + " en línea " + token.beginLine + ", columna " + token.beginColumn);
                tipo = "error";
            }
        } else if (token.kind == linkersOptimizadoConstants.NUMERO) {
            tipo = "int";
        } else if (token.kind == linkersOptimizadoConstants.NUMERO_FLOTANTE) {
            tipo = "float";
        } else if (token.kind == linkersOptimizadoConstants.VERDADERO || token.kind == linkersOptimizadoConstants.FALSO) {
            tipo = "boolean";
        } else if (token.kind == linkersOptimizadoConstants.CADENA) {
            tipo = "string";
        } else if (token.kind == linkersOptimizadoConstants.LETRA) {
            tipo = "char";
        }
        else {
            tipo = "error";
        }
    }
    { return tipo; }
}

void declararVariables() : {} {
    VariableINT() 
    | VariableFLOAT() 
    | VariableBOOLEAN() 
    | VariableCADENA() 
    | VariableCARACTER()
}

/**
 * Este método `VariableINT` se utiliza para definir una variable de tipo entero (INT).
 * 
 * Variables locales:
 * - `Token id`: Representa el identificador del token.
 * - `int line`: Almacena el número de línea donde se encuentra la variable.
 * - `int column`: Almacena el número de columna donde se encuentra la variable.
 * - `boolean control`: Bandera de control que inicialmente está establecida en falso.
 * 
 * Este método no tiene parámetros de entrada ni valores de retorno.
 */
void VariableINT() : {
    Token id;
    int line, column;
    boolean control = false;
} {
    try {
        <TipoDatoEntero>
        id = <IDENTIFICADOR>
        {
            line = id.beginLine;
            column = id.beginColumn;
        }
        (
            try {
                <CorcheteAbre> {
                    Token token = getNextToken();
                    if (token.kind == linkersOptimizadoConstants.NUMERO) {
                        control = true;
                        linkersOptimizado.checkAndAddVariable(id, "int[]", line, column);
                        intermedia.add(new TAC("reserva", token.image, id.image));
                    } else {
                        tabla.add("Error Semántico -> Tamaño de arreglo inválido: " + token.image + " en línea " + token.beginLine + ", columna " + token.beginColumn);
                    }
                }
                <CorcheteCierra>
            } catch (ParseException e) {
                tabla.add("Error de Sintaxis -> " + e.getMessage());
            }
        )?
        {
            if (!control) {
                linkersOptimizado.checkAndAddVariable(id, "int", line, column);
            }
        }
        [ <Asignacion> {
            ExpressionResult exprResult = expresion("int");
            // Generar TAC de asignación si hay inicialización
            String temp = linkersOptimizado.newTemp();
            intermedia.add(new TAC("=", exprResult.place, temp));
            intermedia.add(new TAC("=", temp, id.image));
            // intermedia.add(new TAC("=", exprResult.place, id.image));
        } ]
        <DelimitadorLineaDeCodigo>
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != DelimitadorLineaDeCodigo);
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

/**
 * * Inicializa un token para contener el identificador de la variable, y variables para almacenar los números
 * de línea y columna donde se declara la variable. Además, incluye una variable de control booleana para
  * procesamiento adicional.
 * *
 *  * Variables Locales:
 * - Token id: Representa el token identificador para la variable de punto flotante.
 * -  * - int line: Almacena el número de línea donde se declara la variable.
 * - i * - int column: Almacena el número de columna donde se declara la variable.
 * - in * - boolean control: Una bandera de control utilizada para procesamiento o validación adicional.
 */
void VariableFLOAT() : {
    Token id;
    int line, column;
    boolean control = false;
} {
    try {
        <TipoDatoDecimal>
        id = <IDENTIFICADOR>
        {
            line = id.beginLine;
            column = id.beginColumn;
        }
        (
            try {
                <CorcheteAbre> {
                    Token token = getNextToken();
                    if (token.kind == linkersOptimizadoConstants.NUMERO) {
                        control = true;
                        linkersOptimizado.checkAndAddVariable(id, "float[]", line, column);
                        intermedia.add(new TAC("reserva", token.image, id.image));
                    } else {
                        tabla.add("Error Semántico -> Tamaño de arreglo inválido: " + token.image + " en línea " + token.beginLine + ", columna " + token.beginColumn);
                    }
                }
                <CorcheteCierra>
            } catch (ParseException e) {
                tabla.add("Error de Sintaxis -> " + e.getMessage());
            }
        )?
        {
            if (!control) {
                linkersOptimizado.checkAndAddVariable(id, "float", line, column);
            }
        }
        [ <Asignacion> {
            ExpressionResult exprResult = expresion("float");
            // Generar tac de asignación si hay inicialización
            String temp = linkersOptimizado.newTemp();
            intermedia.add(new TAC("=", exprResult.place, temp));
            intermedia.add(new TAC("=", temp, id.image));
            // intermedia.add(new TAC("=", exprResult.place, id.image));
        } ]
        <DelimitadorLineaDeCodigo>
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != DelimitadorLineaDeCodigo);
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

/**
 * Método que maneja la declaración de variables de tipo BOOLEAN en el compilador.
 * 
 * Variables locales:
 * - Token id: Representa el identificador del token.
 * - int line: Almacena la línea del código fuente donde se encuentra la variable.
 * - int column: Almacena la columna del código fuente donde se encuentra la variable.
 * - boolean control: Bandera de control utilizada en el proceso de manejo de la variable.
 * 
 * Este método es parte del archivo de definiciones del compilador y se encarga de 
 * procesar y validar las declaraciones de variables de tipo BOOLEAN en el código fuente.
 */
void VariableBOOLEAN() : {
    Token id;
    int line, column;
    boolean control = false;
} {
    try {
        <TipoDatoBooleano>
        id = <IDENTIFICADOR>
        {
            line = id.beginLine;
            column = id.beginColumn;
        }
        (
            try {
                <CorcheteAbre> {
                    Token token = getNextToken();
                    if (token.kind == linkersOptimizadoConstants.NUMERO) {
                        control = true;
                        linkersOptimizado.checkAndAddVariable(id, "boolean[]", line, column);
                        intermedia.add(new TAC("reserva", token.image, id.image));
                    } else {
                        tabla.add("Error Semántico -> Tamaño de arreglo inválido: " + token.image + " en línea " + token.beginLine + ", columna " + token.beginColumn);
                    }
                }
                <CorcheteCierra>
            } catch (ParseException e) {
                tabla.add("Error de Sintaxis -> " + e.getMessage());
            }
        )?
        {
            if (!control) {
                linkersOptimizado.checkAndAddVariable(id, "boolean", line, column);
            }
        }
        [ <Asignacion> {
            ExpressionResult exprResult = expresion("boolean");
            // Generar tac de asignación si hay inicialización
            String temp = linkersOptimizado.newTemp();
            intermedia.add(new TAC("=", exprResult.place, temp));
            intermedia.add(new TAC("=", temp, id.image));
            // intermedia.add(new TAC("=", exprResult.place, id.image));
        } ]
        <DelimitadorLineaDeCodigo>
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != DelimitadorLineaDeCodigo);
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

void VariableCADENA() : {
    Token id;
    int line, column;
    boolean control = false;
} {
    try {
        <TipoDatoCadena>
        id = <IDENTIFICADOR>
        {
            line = id.beginLine;
            column = id.beginColumn;
        }
        (
            try {
                <CorcheteAbre> {
                    Token token = getNextToken();
                    if (token.kind == linkersOptimizadoConstants.NUMERO) {
                        control = true;
                        linkersOptimizado.checkAndAddVariable(id, "string[]", line, column);
                        intermedia.add(new TAC("reserva", token.image, id.image));
                    } else {
                        tabla.add("Error Semántico -> Tamaño de arreglo inválido: " + token.image + " en línea " + token.beginLine + ", columna " + token.beginColumn);
                    }
                }
                <CorcheteCierra>
            } catch (ParseException e) {
                tabla.add("Error de Sintaxis -> " + e.getMessage());
            }
        )?
        {
            if (!control) {
                linkersOptimizado.checkAndAddVariable(id, "string", line, column);
            }
        }
        [ <Asignacion> {
            ExpressionResult exprResult = expresion("string");
            // Generar TAC de asignación si hay inicialización
            String temp = linkersOptimizado.newTemp();
            intermedia.add(new TAC("=", exprResult.place, temp));
            intermedia.add(new TAC("=", temp, id.image));
            // intermedia.add(new TAC("=", exprResult.place, id.image));
        } ]
        <DelimitadorLineaDeCodigo>
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != DelimitadorLineaDeCodigo);
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

void VariableCARACTER() : {
    Token id;
    int line, column;
    boolean control = false;
} {
    try {
        <TIpoDatoCaracter>
        id = <IDENTIFICADOR>
        {
            line = id.beginLine;
            column = id.beginColumn;
        }
        (
            try {
                <CorcheteAbre> {
                    Token token = getNextToken();
                    if (token.kind == linkersOptimizadoConstants.NUMERO) {
                        control = true;
                        linkersOptimizado.checkAndAddVariable(id, "char[]", line, column);
                        intermedia.add(new TAC("reserva", token.image, id.image));
                    } else {
                        tabla.add("Error Semántico -> Tamaño de arreglo inválido: " + token.image + " en línea " + token.beginLine + ", columna " + token.beginColumn);
                    }
                }
                <CorcheteCierra>
            } catch (ParseException e) {
                tabla.add("Error de Sintaxis -> " + e.getMessage());
            }
        )?
        {
            if (!control) {
                linkersOptimizado.checkAndAddVariable(id, "char", line, column);
            }
        }
        [ <Asignacion> {
            ExpressionResult exprResult = expresion("char");
            // Generar tac de asignación si hay inicialización
            String temp = linkersOptimizado.newTemp();
            intermedia.add(new TAC("=", exprResult.place, temp));
            intermedia.add(new TAC("=", temp, id.image));
            // intermedia.add(new TAC("=", exprResult.place, id.image));
        } ]
        <DelimitadorLineaDeCodigo>
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != DelimitadorLineaDeCodigo);
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

/**
 * Este método representa una regla de asignación en un compilador.
 * 
 * Variables locales:
 * - `id`: Un token que representa el identificador de la variable a la que se le asignará un valor.
 * - `varType`: Una cadena que almacena el tipo de la variable. Inicialmente está vacía.
 * - `exprResult`: Un objeto de tipo `ExpressionResult` que almacena el resultado de la expresión que se asignará a la variable.
 * 
 * La implementación de este método debe definir cómo se realiza la asignación de valores a las variables,
 * incluyendo la verificación de tipos y la evaluación de la expresión.
 */
void asignacion() : {
    Token id;
    String varType = "";
    ExpressionResult exprResult;
} {
    try {
        id = <IDENTIFICADOR>
        {
            if (!linkersOptimizado.declaredVariables.containsKey(id.image)) {
                linkersOptimizado.tabla.add("Error Semántico -> Variable no declarada: " + id.image + " en línea " + id.beginLine + ", columna " + id.beginColumn);
            } else {
                varType = linkersOptimizado.declaredVariables.get(id.image);
            }
        }
        <Asignacion>
        {
            exprResult = expresion(varType);
            if (!exprResult.type.equals(varType)) {
                linkersOptimizado.tabla.add("Error Semántico -> Tipo incorrecto en la operación. Se esperaba: " + varType + " pero se obtuvo: " + exprResult.type + " en línea " + id.beginLine + ", columna " + id.beginColumn);
            }
            // Generar TAC de asignación
            String temp = linkersOptimizado.newTemp();
            intermedia.add(new TAC("=", exprResult.place, temp));
            intermedia.add(new TAC("=", temp, id.image));
            // intermedia.add(new TAC("=", exprResult.place, id.image));
        }
        <DelimitadorLineaDeCodigo>
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != DelimitadorLineaDeCodigo && t.kind != EOF);
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

void entrada() : {} {
    try {
        <Lectura>
        try {
            <ParentesisAbre>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }

        {
            /**
             * Este fragmento de código consume un token del analizador léxico (lexer) en un compilador.
             * 
             * - `jj_consume_token(linkersOptimizadoConstants.IDENTIFICADOR)`: Esta llamada al método `jj_consume_token` 
             *   consume el siguiente token de la secuencia de entrada si coincide con el tipo de token 
             *   especificado, en este caso `linkersOptimizadoConstants.IDENTIFICADOR`. 
             *   Si el token no coincide, se lanzará una excepción de error de sintaxis.
             * 
             * - `Token token`: La variable `token` almacena el token consumido, que puede ser utilizado 
             *   posteriormente en el análisis sintáctico o semántico.
             */
            Token token = jj_consume_token(linkersOptimizadoConstants.IDENTIFICADOR);
            if (!linkersOptimizado.declaredVariables.containsKey(token.image)) {
                linkersOptimizado.tabla.add("Error Semántico en entrada-> Variable no declarada: " + token.image + " en línea " + token.beginLine + ", columna " + token.beginColumn);
            } else {
                // Generar TAC de lectura
                intermedia.add(new TAC("Leer", token.image));
            }
        }
        try {
            <ParentesisCierra>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        try {
            <DelimitadorLineaDeCodigo>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != DelimitadorLineaDeCodigo);
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

/**
 * El método `salida` es un método que no recibe parámetros y devuelve un valor de tipo `void`.
 * 
 * Dentro del bloque de inicialización del método, se declaran dos variables locales:
 * - `res` de tipo `ExpressionResult`.
 * - `temporal` de tipo `TAC`, que se inicializa con una nueva instancia de `TAC`.
 * 
 * El método `salida` no tiene un cuerpo de implementación definido en el código proporcionado,
 * lo que sugiere que podría estar incompleto o que su funcionalidad se define en otra parte.
 * 
 */
void salida() : {
    ExpressionResult res;
    TAC temporal = new TAC();
} {
    try {
        <Escritura>
        try {
            <ParentesisAbre>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }

        {
            Token token = getToken(1);
            String temp = "";
            boolean isConcatenation = false;

            // Si unicamente tenemos una cadena, se mostrara directamente 
            if (token.kind == linkersOptimizadoConstants.CADENA) {
                jj_consume_token(linkersOptimizadoConstants.CADENA);
                temp = newTemp();
                temporal = new TAC("ESCRIBIR", token.image);
            } else if (token.kind == linkersOptimizadoConstants.IDENTIFICADOR) {
                // Si es un identificador, verificamos que exista y obtenemos su tipo
                String type = linkersOptimizado.verificarExistenciaYObtenerTipo(token);
                if (!type.equals("error")) {
                    temp = newTemp();
                    temporal = new TAC("ESCRIBIR", token.image);
                }
            } else {
                tabla.add("Error Semántico -> Tipo incorrecto en operación de escritura. Se esperaba: Cadena o Identificador");
            }

            int cont = 0;
            String temp2 = "";
            while (nextTokenIs(linkersOptimizadoConstants.OperacionSuma)) {
                isConcatenation = true;
                if (cont == 0) {
                    intermedia.add(new TAC("=", temporal.getResult(), temp));
                } 
                jj_consume_token(linkersOptimizadoConstants.OperacionSuma);
                token = getToken(1);
                temp = (cont != 0) ? temp2: temp;
                temp2 = newTemp();
                if (token.kind == linkersOptimizadoConstants.CADENA) {
                    jj_consume_token(linkersOptimizadoConstants.CADENA);
                    intermedia.add(new TAC("+", temp, token.image, temp2));
                } else if (token.kind == linkersOptimizadoConstants.IDENTIFICADOR) {
                    jj_consume_token(linkersOptimizadoConstants.IDENTIFICADOR);
                    if (!linkersOptimizado.declaredVariables.containsKey(token.image)) {
                        tabla.add("Error Semántico -> Variable no declarada: " + token.image + " en línea " + token.beginLine + ", columna " + token.beginColumn);
                    } else {
                        intermedia.add(new TAC("+", temp, token.image, temp2));
                    }
                } else {
                    tabla.add("Error Semántico -> Tipo incorrecto en operación de escritura. Se esperaba: Cadena o Identificador" + " en línea " + token.beginLine + ", columna " + token.beginColumn);
                    jj_consume_token(token.kind);
                }
                cont += 1;
            }   

            if (isConcatenation) {
                intermedia.add(new TAC("ESCRIBIR", temp2));
            } else {
                intermedia.add(temporal);
            }
        }
        try {
            <ParentesisCierra>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        try {
            <DelimitadorLineaDeCodigo>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != DelimitadorLineaDeCodigo && t.kind != EOF);
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

void condicionalIf() : {
    String condFalseLabel;
    String endLabel, startLabel, lb;
    ExpressionResult condResult;
    int posicionInicial = 0, posicionPrevCasos = 0;
} {
    try {
        {
            endLabel= linkersOptimizado.newLabelNoPoint();
            labelCounter--;
            lb = linkersOptimizado.newLabelNoPoint();
            intermedia.add(new TAC("", ""));  //Salto de linea
            if(!casos.isEmpty()){
                casos.clear();
            }
            if(contadorCondiciones != 0){
                contadorCondiciones = 0;
            }

            if( posicionInicial == 0){
                //posición después de dar un salto de linea
                posicionInicial = intermedia.size() - 1; 
                //intermedia.add(new TAC("POSICION : " + (posicionInicial + 1), ""));
            }

        }
        parteIf(lb, endLabel)

        ( parteElseIf(endLabel) )*
        
        //[ parteElse(endLabel) ]
        {  
            posicionPrevCasos = intermedia.size() - 1;
            //Esta parte es únicamente para generar el bloque de los IF
            //intermedia.add(new TAC(lb, ""));    //Nueva etiqueta temporal
            for (String iterador : casos) {
                intermedia.add(new TAC(iterador, ""));
            }

            //intermedia.add(new TAC("GOTO ", endLabel));
            

            posicionInicial = posicionInicial + contadorCondiciones;
            //Tamaño final de la lista hasta añadir todos los case y el final
            int posicionPostCases = intermedia.size() - 1;
            int pos3 = posicionPostCases - posicionPrevCasos;
            
            //intermedia.add(new TAC("POSICION: " + (posicionPostCases + 1),""));

            ArrayList<TAC> temporal = moverUltimosNAntesDePosicion(intermedia,  pos3, posicionInicial);
            intermedia = temporal;

            //for(int i = posicionInicial; i < posicionPostCases; i++){
            //    // lista, posición inicial, Por quien se va a cambiar
            //    cambiarPosicion(intermedia, posicionPostCases, i);
            //}
            posicionInicial = 0;
            posicionPostCases = 0;
            posicionPrevCasos = 0;

            intermedia.add(new TAC(endLabel, ":"));

        }
    } catch (ParseException e) {
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}



void parteIf(String previousLabel,String endLabel) : {
    String startLabel;
    ExpressionResult condResult;
}
{
    <CondicionalIf>
        try {
            <ParentesisAbre>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        { 
            startLabel = linkersOptimizado.newLabelNoPoint();
            condResult = condicion();
            //intermedia.add(new TAC("GOTO ", previousLabel));
            contadorCondiciones++;

        }
        try {
            <ParentesisCierra>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }

        {
            casos.add("IF " + condResult.place + " GOTO "+ startLabel);
            //casos.add("GOTO " + endLabel);
        }
        try {
            <LlaveAbre>{
                intermedia.add(new TAC(startLabel,""));
            }
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        (sentencias())*
        try {
            <LlaveCierra>{
                intermedia.add(new TAC("GOTO",endLabel));
            }
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
}


void parteElseIf(String endLabel) : {
    String startLabel = "";
    Token id;
    String nuevaLabel="";
    ExpressionResult condResult;
    ArrayList <String> cPrueba = new ArrayList<>();
}
{
    try{
        <CondicionalElse>
        {
            id = getToken(1);
            startLabel = linkersOptimizado.newLabelNoPoint();
            if(id.image != "if"){
                intermedia.add (new TAC(startLabel+":", ""));
            }
            if(id.image == "{"){
                casos.add("GOTO " + startLabel);
            }
        }
        
        [<CondicionalIf>
        try {
            <ParentesisAbre>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        condResult = condicion()

        try {
            <ParentesisCierra>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }

        {
            intermedia.add(new TAC(nuevaLabel, ""));
            casos.add("IF " + condResult.place + " GOTO " + startLabel);
        }
        ]
        try {
            <LlaveAbre>{
                //intermedia.add(new TAC("LABEL", startLabel+":"));
            }
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        (sentencias())*{
            
            intermedia.add(new TAC("GOTO",endLabel));
        }
        try {
            <LlaveCierra>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }

    }catch (ParseException e) {
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

void parteElse(String endLabel) : {
    String startLabel = "";
    Token sent;
}
{
    try{
        //try{
            <CondicionalElse>
        //}catch (ParseException e){
        //    return;
        //}

        try {
            <LlaveAbre>

        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        (sentencias())*
        try {
            <LlaveCierra>{
                intermedia.add(new TAC("GOTO ", endLabel));
            }
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }

    }catch (ParseException e ){
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}


// Método auxiliar para manejar el bloque else opcional
void condicionalElseBlock() : {} {
    try {
        (
            // Intentar consumir 'else'
            try {
                <CondicionalElse>
            } catch (ParseException e) {
                // No hay bloque else, regresar
                return;
            }
            try {
                <LlaveAbre>
            } catch (ParseException e) {
                tabla.add("Error de Sintaxis -> " + e.getMessage());
            }
            (sentencias())*
            try {
                <LlaveCierra>
            } catch (ParseException e) {
                tabla.add("Error de Sintaxis -> " + e.getMessage());
            }
        )
    } catch (ParseException e) {
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

void condicionalIfthen() : {
    String condFalseLabel;
    ExpressionResult condResult;
} {
    // Este método puede ser eliminado si no se utiliza o ajustado según las necesidades
    try {
        <CondicionalIfthen>
        try {
            <ParentesisAbre>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        { condResult = condicion(); }
        try {
            <ParentesisCierra>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        {
            condFalseLabel = linkersOptimizado.newLabel();
            // Generar salto condicional
            intermedia.add(new TAC("ifFalse", condResult.place, condFalseLabel));
        }
        try {
            <LlaveAbre>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        (sentencias())*
        try {
            <LlaveCierra>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        {
            // Añadir etiqueta para el fin del bloque ifthen
            intermedia.add(new TAC("LABEL", condFalseLabel));
        }
    } catch (ParseException e) {
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}



void cicloFor() : {
    String startLabel, endLabel;
    ExpressionResult condResult;
} {
    try {
        <CicloFor>
        try {
            <ParentesisAbre>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }

        (declararVariables() | asignacion())
        {
            startLabel = linkersOptimizado.newLabel();
            intermedia.add(new TAC("",""));
            intermedia.add(new TAC("LABEL", startLabel));
        }
        { condResult = condicion(); }
        {
            endLabel = linkersOptimizado.newLabel();
            // Generar salto condicional
            intermedia.add(new TAC("ifFalse", condResult.place, endLabel));
        }
        try {
            <DelimitadorLineaDeCodigo>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }

        //{ asignacion(); }
        {  
            {
                
            }
            asignacionLogica(); 
        }{}
        try {
            <ParentesisCierra>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        try {
            <LlaveAbre>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }

        (sentencias())*
        {
            // Salto al inicio del ciclo
            intermedia.add(new TAC("GOTO", startLabel));
            // Etiqueta de fin del ciclo
            intermedia.add(new TAC("LABEL", endLabel));
        }
        try {
            <LlaveCierra>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
    } catch (ParseException e) {
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

void asignacionLogica() : {
    Token id, num;
    String varType = "", oper;
    ExpressionResult exprResult;
} {
    try {
        id = <IDENTIFICADOR>
        {
            if (!linkersOptimizado.declaredVariables.containsKey(id.image)) {
                linkersOptimizado.tabla.add("Error Semántico -> Variable no declarada: " + id.image + " en línea " + id.beginLine + ", columna " + id.beginColumn);
            } else {
                varType = linkersOptimizado.declaredVariables.get(id.image);
            }
        }{
            String tmp1 = linkersOptimizado.newTemp();
            intermedia.add(new TAC("=", "0", tmp1));
            intermedia.add(new TAC("=", tmp1, id.image));
        }
         oper = operadorAritmetico()
        {
            exprResult = expresion(varType);
            if (!exprResult.type.equals(varType)) {
                linkersOptimizado.tabla.add("Error Semántico -> Tipo incorrecto en la operación. Se esperaba: " + varType + " pero se obtuvo: " + exprResult.type + " en línea " + id.beginLine + ", columna " + id.beginColumn);
            }
            // Generar TAC de asignación
            String temp = linkersOptimizado.newTemp();
        }
        num = <NUMERO> {
            
            intermedia.add(new TAC("=", exprResult.place + num.image, temp));
            intermedia.add(new TAC("=", temp, id.image));
        }
    } catch (ParseException e) {
        //
    }
}

void cicloWhile() : {
    String startLabel, endLabel;
    ExpressionResult condResult;
} {
    try {
        <CicloWhile>
        {
            intermedia.add(new TAC("", ""));
            startLabel = linkersOptimizado.newLabel();
            intermedia.add(new TAC("LABEL", startLabel));
        }
        try {
            <ParentesisAbre>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        { condResult = condicion(); }
        {
            endLabel = linkersOptimizado.newLabel();
            // Generar salto condicional
            intermedia.add(new TAC("ifFalse", condResult.place, endLabel));
        }
        try {
            <ParentesisCierra>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        try {
            <LlaveAbre>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        (sentencias())*
        {
            // Salto al inicio del ciclo
            intermedia.add(new TAC("GOTO", startLabel));
            // Etiqueta de fin del ciclo
            intermedia.add(new TAC("LABEL", endLabel));
        }
        asignacionLogica()
        try {
            <LlaveCierra>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
    } catch (ParseException e) {
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

void condicionalSwitch() : {
    Token id;
    ExpressionResult exprResult;
    int tmp = 0, posicionInicial = 0, posicionPrevCasos = 0;
} {
    try {
        <CondicionalSwitch>
        <ParentesisAbre>
        id = <IDENTIFICADOR>{

            if (!casos.isEmpty()){
                casos.clear();
            }
            String tmp1 = linkersOptimizado.newTemp();
            labelCounter--;
            String lb = linkersOptimizado.newLabelNoPoint();
            String lbFin = linkersOptimizado.newLabelNoPoint();
            intermedia.add(new TAC("", "")); //Salto de linea
            intermedia.add(new TAC("=", id.image, tmp1));
            if( posicionInicial == 0){
                //posición después de dar un salto de linea
                posicionInicial = intermedia.size() - 1; 
            }

        }
        <ParentesisCierra>
        <LlaveAbre>
        {
            if (!linkersOptimizado.declaredVariables.containsKey(id.image)) {
                linkersOptimizado.tabla.add("Error Semántico -> Variable no declarada: " + id.image + " en línea " + id.beginLine + ", columna " + id.beginColumn);
            }
        } 
          
        ({
            cases = cases + 1;
            tmp = tempVarCounter - cases;
        }
            caso(tmp,lbFin)
        )*{
            posicionPrevCasos = intermedia.size() - 1;
            //intermedia.add(new TAC(lb, ""));

            for (String iterador : casos) {
                intermedia.add(new TAC(iterador, ""));
            }
            
            posicionInicial = posicionInicial + contadorCondiciones - 1;
            int posicionPostCases = intermedia.size() - 1;
            int pos3 = posicionPostCases - posicionPrevCasos;

            ArrayList<TAC> temporal = moverUltimosNAntesDePosicion(intermedia,  pos3, posicionInicial);
            intermedia = temporal;            

            //Label final
            //intermedia.add(new TAC("GOTO ", lbFin));
            intermedia.add(new TAC(lbFin, ""));

            posicionInicial = 0;
            posicionPostCases = 0;
            posicionPrevCasos = 0;
        }
        (
            defaultCaso()
        )?
        <LlaveCierra>
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != LlaveCierra && t.kind != EOF);
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

void caso(int opcion, String labelFin) : {
    Token caseValue, idnext, id;
} {
    <Caso>
    caseValue = <NUMERO>
    <DelimitadorCasoSwitch>
    {
        id = getToken(-1);
        idnext = getToken(1);
        String LABEL = linkersOptimizado.newLabelNoPoint();
        intermedia.add(new TAC("LABEL", LABEL+":"));
        //intermedia.add(new TAC("if", id.image + " == " + caseValue.image, "GOTO " + LABEL));
        casos.add("if " + ("t" + opcion) + " == " + caseValue.image + " GOTO " + LABEL);
        //intermedia.add(new TAC(image.))
    }
    (
        sentencias()
    )*{
        intermedia.add(new TAC("GOTO "+labelFin, ""));
    }
    <Break>
    <DelimitadorLineaDeCodigo>
}

void defaultCaso() : {
    String LABEL = linkersOptimizado.newLabel();
} {
    <Default>
    <DelimitadorCasoSwitch>
    {
        intermedia.add(new TAC("LABEL", LABEL));
    }
    (
        sentencias()
    )*
}

void procedimiento() : {
    Token id;
    String startLabel, endLabel;
    ArrayList<Parameter> parameters = new ArrayList<>();

} {
    try {
        <NoRetorno>
        id = <IDENTIFICADOR>
        <ParentesisAbre>
        {
            parameters = listaParametros();
        }
        <ParentesisCierra>
        <Start>
        {
            startLabel = linkersOptimizado.newLabel();
            endLabel = linkersOptimizado.newLabel();
            intermedia.add(new TAC("LABEL", startLabel)); // Etiqueta de inicio del procedimiento
            // Agregar los parámetros a la tabla de variables declaradas
            for (Parameter param : parameters) {
                linkersOptimizado.declaredVariables.put(param.name, param.type);
            }
        }
        (sentencias())+
        {
            intermedia.add(new TAC("GOTO", endLabel)); // Salto al final del procedimiento
            intermedia.add(new TAC("", endLabel)); // Etiqueta de fin del procedimiento
        }
        <End>
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != linkersOptimizadoConstants.LlaveCierra && t.kind != EOF);
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

ArrayList<Parameter> listaParametros() : {
    ArrayList<Parameter> parameters = new ArrayList<>();
    Parameter param;
} {
    (
        param = parametro()
        {
            parameters.add(param);
        }
        (
            <Coma>
            param = parametro()
            {
                parameters.add(param);
            }
        )*
    )?
    { return parameters; }
}

Parameter parametro() : {
    Token id;
    String type;
} {
    (
        <TipoDatoEntero> { type = "int"; }
        | <TipoDatoDecimal> { type = "float"; }
        | <TipoDatoBooleano> { type = "boolean"; }
        | <TipoDatoCadena> { type = "string"; }
        | <TIpoDatoCaracter> { type = "char"; }
    )
    id = <IDENTIFICADOR>
    
    { return new Parameter(id.image, type); }
}

void funcion() : {
    Token id;
    String startLabel, endLabel;
    ArrayList<Parameter> parameters = new ArrayList<>();
    String returnType = "";
} {
    try {
        (<PUBLICO> | <PRIVADO>)
        (
            <TipoDatoEntero> { returnType = "int"; }
            | <TipoDatoDecimal> { returnType = "float"; }
            | <TipoDatoCadena> { returnType = "string"; }
            | <TIpoDatoCaracter> { returnType = "char"; }
        )
        id = <IDENTIFICADOR>
        <ParentesisAbre>
        {
            parameters = listaParametros();
        }
        <ParentesisCierra>
        <Start>
        {
            startLabel = linkersOptimizado.newLabel();
            endLabel = linkersOptimizado.newLabel();
            intermedia.add(new TAC("LABEL", startLabel)); // Etiqueta de inicio de la función
            // Agregar los parámetros a la tabla de variables declaradas
            for (Parameter param : parameters) {
                linkersOptimizado.declaredVariables.put(param.name, param.type);
            }
        }
        (sentencias())*
        (retorno(returnType))?
        {
            intermedia.add(new TAC("GOTO", endLabel)); // Salto al final de la función
            intermedia.add(new TAC("LABEL", endLabel)); // Etiqueta de fin de la función
        }
        <End>
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != linkersOptimizadoConstants.LlaveCierra && t.kind != EOF);
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

void retorno(String returnType) : {
    ExpressionResult exprResult;
} {
    try {
        <Retorno>
        {
            exprResult = expresion(returnType);
            if (!exprResult.type.equals(returnType)) {
                tabla.add("Error Semántico -> Tipo de retorno incorrecto. Se esperaba: " + returnType + " pero se obtuvo: " + exprResult.type);
            }
            // Generar TAC de retorno
            intermedia.add(new TAC("return", exprResult.place));
        }
        <DelimitadorLineaDeCodigo>
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != DelimitadorLineaDeCodigo && t.kind != EOF);
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

ExpressionResult llamadaFuncion() : {
    Token id;
    ArrayList<ExpressionResult> argumentos = new ArrayList<>();
    String funcName;
    String returnType = "";
} {
    try {
        <LlamarFuncion>
        id = <IDENTIFICADOR>
        <ParentesisAbre>
        {
            funcName = id.image;
            if (!linkersOptimizado.declaredVariables.containsKey(funcName)) {
                linkersOptimizado.tabla.add("Error Semántico -> Función no declarada: " + funcName + " en línea " + id.beginLine + ", columna " + id.beginColumn);
            } else {
                returnType = linkersOptimizado.declaredVariables.get(funcName);
            }
        }  
        (argumentos = listaArgumentos())
    <ParentesisCierra>
    {
        // Generar TAC para la llamada a la función
        String temp = linkersOptimizado.newTemp();
        intermedia.add(new TAC("call", funcName, temp));
        for (ExpressionResult arg : argumentos) {
            intermedia.add(new TAC("param", arg.place));
        }
        return new ExpressionResult(returnType, temp);
    }
    <DelimitadorLineaDeCodigo>
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != DelimitadorLineaDeCodigo && t.kind != EOF);
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

ArrayList<ExpressionResult> listaArgumentos() : {
    ArrayList<ExpressionResult> argumentos = new ArrayList<>();
    ExpressionResult arg;
} {
        arg = expresion("any")
        {
            argumentos.add(arg);
        }
        (
            <Coma>
            arg = expresion("any")
            {
                argumentos.add(arg);
            }
        )*

    { return argumentos; }
}

ExpressionResult condicion() : {
    ExpressionResult left, right;
    String op;
} {
    left = condicionSimple()
    (
        { if (nextTokenIsOperatorLogico()) { // Verificamos si viene un operador lógico
            op = operadorLogico();
            right = condicionSimple();
            String temp = linkersOptimizado.newTemp();
            intermedia.add(new TAC(op, left.place, right.place, temp));
            left = new ExpressionResult("boolean", temp);
        }}
    ) // Eliminamos el * o + ya que no queremos repeticiones vacías
    {contadorCondiciones++;}
    { return left; }
}

ExpressionResult condicionSimple() : {
    Token token1, token2;
    String type1 = "", type2 = "";
    String op;
    ExpressionResult left, right;
} {
    {
        left = valor("any"); // Permitir cualquier tipo
        op = operadorRelacional();
        right = valor("any"); // Permitir cualquier tipo

        // Verificar que ambos operandos sean del mismo tipo o tipos compatibles
        if (!left.type.equals(right.type) && !left.type.equals("error") && !right.type.equals("error")) {
            tabla.add("Error Semántico en condición-> Tipos incompatibles en la condición: " + left.type + " y " + right.type);
        }

        // Generar una variable temporal para el resultado booleano
        String temp = linkersOptimizado.newTemp();
        intermedia.add(new TAC(op, left.place, right.place, temp));

        return new ExpressionResult("boolean", temp);
    }
}

String operadorRelacional() : {
    Token opToken;
    String opStr;
} {
    (
        opToken = <OperacionMayorQue> { opStr = ">"; }
        | opToken = <OperacionMenorQue> { opStr = "<"; }
        | opToken = <OperacionMenorOIgualQue> { opStr = "<="; }
        | opToken = <OperacionMayorOIgualQue> { opStr = ">="; }
        | opToken = <OperacionIgualdad> { opStr = "=="; }
        | opToken = <OperacionDesigualdad> { opStr = "!="; }
    )
    { return opStr; }
}

String operadorLogico() : {
    Token opToken;
    String opStr;
} {
    (
        opToken = <OperacionAnd> { opStr = "&"; }
        | opToken = <OperacionOr> { opStr = "|"; }
        | opToken = <OperacionNot> { opStr = "!"; }
    )
    { return opStr; }
}

String operadorAritmetico() : {
    Token opToken;
    String opStr;
} {
    (
        opToken = <OperacionSuma> { opStr = "+"; }
        | opToken = <OperacionResta> { opStr = "-"; }
        | opToken = <OperacionMultiplicacion> { opStr = "*"; }
        | opToken = <OperacionDivision> { opStr = "/"; }
        | opToken = <OperacionResiduo> { opStr = "%"; }
    )
    { return opStr; }
}

ExpressionResult expresion(String expectedType) : {
    ExpressionResult left, right;
    String op;
} {
    left = termino(expectedType)
    (
        { if (nextTokenIsOperadorAritmetico()) {
            op = operadorAritmetico();
            right = termino(expectedType);

            // Verificar si la operación es válida según el tipo esperado
            if (op.equals("+") && (left.type.equals("string") || right.type.equals("string"))) {
                // Si es concatenación y alguno es cadena, convertimos ambos operandos a cadena
                if (!left.type.equals("string")) {
                    String tempLeft = linkersOptimizado.newTemp();
                    intermedia.add(new TAC("toString", left.place, tempLeft));
                    left = new ExpressionResult("string", tempLeft);
                }
                if (!right.type.equals("string")) {
                    String tempRight = linkersOptimizado.newTemp();
                    intermedia.add(new TAC("toString", right.place, tempRight));
                    right = new ExpressionResult("string", tempRight);
                }
            } 
            else if (!left.type.equals(right.type)) {
                // Si no son compatibles, generamos un error
                tabla.add("Error Semántico en expresión-> Tipos incompatibles: " + left.type + " y " + right.type);
            }

            // Generamos el código intermedio con una nueva variable temporal
            String temp = linkersOptimizado.newTemp();
            intermedia.add(new TAC(op, left.place, right.place, temp));
            left = new ExpressionResult(expectedType, temp);
        }}
    ) // Eliminamos el * o + ya que no queremos repeticiones vacías
    { return left; }
}



ExpressionResult termino(String expectedType) : {
    ExpressionResult left, right;
    String op;
} {
    left = factor(expectedType) 
    (
        { if (nextTokenIsOperadorAritmetico()) {
            op = operadorAritmetico();
            right = factor(expectedType); // Procesamos el siguiente factor

            if (!left.type.equals(expectedType) || !right.type.equals(expectedType)) {
                // Si los tipos no coinciden con lo esperado, lanzamos un error
                tabla.add("Error Semántico -> Tipo incorrecto en operación. Se esperaba: " + expectedType);
            }

            // Generamos el código intermedio
            String temp = linkersOptimizado.newTemp();
            intermedia.add(new TAC(op, left.place, right.place, temp));
            left = new ExpressionResult(expectedType, temp);
        }}
    ) // Eliminamos el * o + ya que no queremos repeticiones vacías
    { return left; }
}


ExpressionResult factor(String expectedType) : {
    Token token = null;
    String type = "";
    String place = "";
    ExpressionResult res = null; // Inicialización corregida
} {
    try {
        {if (nextTokenIs(linkersOptimizadoConstants.ParentesisAbre)) {
            res = operacionParentesis(expectedType);
            type = res.type;
            place = res.place;
        } else if (nextTokenIs(linkersOptimizadoConstants.NUMERO)) {
            token = jj_consume_token(linkersOptimizadoConstants.NUMERO);
            type = "int";
            place = token.image;
        } else if (nextTokenIs(linkersOptimizadoConstants.NUMERO_FLOTANTE)) {
            token = jj_consume_token(linkersOptimizadoConstants.NUMERO_FLOTANTE);
            type = "float";
            place = token.image;
        } else if (nextTokenIs(linkersOptimizadoConstants.VERDADERO)) {
            token = jj_consume_token(linkersOptimizadoConstants.VERDADERO);
            type = "boolean";
            place = "1";
        } else if (nextTokenIs(linkersOptimizadoConstants.FALSO)) {
            token = jj_consume_token(linkersOptimizadoConstants.FALSO);
            type = "boolean";
            place = "0";
        } else if(nextTokenIs(linkersOptimizadoConstants.CADENA)) {
            token = jj_consume_token(linkersOptimizadoConstants.CADENA);
            type = "string";
            place = token.image;
        } else if (nextTokenIs(linkersOptimizadoConstants.LETRA)) {
            token = jj_consume_token(linkersOptimizadoConstants.LETRA);
            type = "character";
            place = token.image;
        } else if (nextTokenIs(linkersOptimizadoConstants.IDENTIFICADOR)) {
            token = jj_consume_token(linkersOptimizadoConstants.IDENTIFICADOR);
            if (linkersOptimizado.declaredVariables.containsKey(token.image)) {
                type = linkersOptimizado.declaredVariables.get(token.image);
                place = token.image;
            } else {
                tabla.add("Error Semántico -> Variable no declarada: " + token.image + " en línea " + token.beginLine + ", columna " + token.beginColumn);
                type = "error";
            }
        } else if (nextTokenIs(linkersOptimizadoConstants.Funcion)) {
            res = llamadaFuncion();
            type = res.type;
            place = res.place;
        } else {
            type = "error";
        }}

        // Verificar tipos si se espera uno específico
        {if (token != null && !"any".equals(expectedType) && !type.equals(expectedType) && !type.equals("error")) {
            tabla.add("Error Semántico -> Tipo incorrecto. Se esperaba: " + expectedType + " pero se obtuvo: " + type + " en línea " + token.beginLine + ", columna " + token.beginColumn);
        }}
    } catch (ParseException e) {
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
    {return (res != null) ? res : new ExpressionResult(type, place);}
}

boolean nextTokenIs(int kind) : {
    Token t;
} {
    {t = getToken(1);
    return t.kind == kind;}
}

// Métodos auxiliares para detectar operadores
boolean nextTokenIsOperatorLogico() : {
    Token t;
} {
    {t = getToken(1);
    return t.kind == linkersOptimizadoConstants.OperacionAnd || t.kind == linkersOptimizadoConstants.OperacionOr || t.kind == linkersOptimizadoConstants.OperacionNot;}
}

boolean nextTokenIsOperadorAritmetico() : {
    Token t;
} {
    {t = getToken(1);
    return t.kind == linkersOptimizadoConstants.OperacionSuma || t.kind == linkersOptimizadoConstants.OperacionResta || 
           t.kind == linkersOptimizadoConstants.OperacionMultiplicacion || t.kind == linkersOptimizadoConstants.OperacionDivision ||
           t.kind == linkersOptimizadoConstants.OperacionResiduo;}
}

ExpressionResult operacionParentesis(String expectedType) : {
    ExpressionResult res=null;
} {
    try {
        {jj_consume_token(linkersOptimizadoConstants.ParentesisAbre);
        res = expresion(expectedType);
        jj_consume_token(linkersOptimizadoConstants.ParentesisCierra);

        if (!res.type.equals(expectedType)) {
            tabla.add("Error Semántico -> Tipo incorrecto en la operación entre paréntesis. Se esperaba: " + expectedType + " pero se obtuvo: " + res.type);
        }}
    } catch (ParseException e) {
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
    {return res;}
}

ExpressionResult valor(String expectedType) : {
    Token token = null;
    String type = "";
    String place = "";
} {
    try {
        {if (nextTokenIs(linkersOptimizadoConstants.NUMERO)) {
            token = jj_consume_token(linkersOptimizadoConstants.NUMERO);
            type = "int";
            place = token.image;
        } else if (nextTokenIs(linkersOptimizadoConstants.NUMERO_FLOTANTE)) {
            token = jj_consume_token(linkersOptimizadoConstants.NUMERO_FLOTANTE);
            type = "float";
            place = token.image;
        } else if (nextTokenIs(linkersOptimizadoConstants.VERDADERO)) {
            token = jj_consume_token(linkersOptimizadoConstants.VERDADERO);
            type = "boolean";
            place = "1";
        } else if (nextTokenIs(linkersOptimizadoConstants.FALSO)) {
            token = jj_consume_token(linkersOptimizadoConstants.FALSO);
            type = "boolean";
            place = "0";
        } else if(nextTokenIs(linkersOptimizadoConstants.CADENA)) {
            token = jj_consume_token(linkersOptimizadoConstants.CADENA);
            type = "string";
            place = token.image;
        } else if (nextTokenIs(linkersOptimizadoConstants.LETRA)) {
            token = jj_consume_token(linkersOptimizadoConstants.LETRA);
            type = "character";
            place = token.image;
        } else if (nextTokenIs(linkersOptimizadoConstants.IDENTIFICADOR)) {
            token = jj_consume_token(linkersOptimizadoConstants.IDENTIFICADOR);
            if (linkersOptimizado.declaredVariables.containsKey(token.image)) {
                type = linkersOptimizado.declaredVariables.get(token.image);
                place = token.image;
            } else {
                tabla.add("Error Semántico -> Variable no declarada: " + token.image + " en línea " + token.beginLine + ", columna " + token.beginColumn);
                type = "error";
            }
        } else {
            tabla.add("Error Semántico -> Token inesperado en la condición.");
            throw new ParseException("Token inesperado en la condición.");
        }}

        // Verificar tipos si se espera uno específico
        {if (token != null && !"any".equals(expectedType) && !type.equals(expectedType) && !type.equals("error")) {
            tabla.add("Error Semántico -> Tipo incorrecto. Se esperaba: " + expectedType + " pero se obtuvo: " + type + " en línea " + token.beginLine + ", columna " + token.beginColumn);
        }}
    } catch (ParseException e) {
        tabla.add("Error de Sintaxis -> " + e.getMessage());
        throw e;
    }
    {return new ExpressionResult(type, place);}
}

ExpressionResult concatenar() : {
    ExpressionResult left, right;
    String temp;
    Token token = null;
} {
    left = expresion("string")// Empezamos con una expresión inicial, esperando tipo cadena
    (
        {if (nextTokenIsOperadorAritmetico() && getToken(1).image.equals("+")) { // Concatenación con operador "+"
        jj_consume_token(linkersOptimizadoConstants.OperacionSuma); // Consumimos el "+" operador

        // Evaluamos el siguiente valor en la concatenación
        right = expresion("string");

        // Si los tipos no son compatibles, convertimos a cadena
        if (!left.type.equals("string")) {
            temp = linkersOptimizado.newTemp();
            intermedia.add(new TAC("toString", left.place, temp)); // Conversión a cadena
            left = new ExpressionResult("string", temp);
        }
        if (!right.type.equals("string")) {
            temp = linkersOptimizado.newTemp();
            intermedia.add(new TAC("toString", right.place, temp)); // Conversión a cadena
            right = new ExpressionResult("string", temp);
        }

        // Generamos una nueva variable temporal para la concatenación
        temp = linkersOptimizado.newTemp();
        intermedia.add(new TAC("+", left.place, right.place, temp));
        left = new ExpressionResult("string", temp);
        }}
    )    
    { return left; }
}
