options {
    LOOKAHEAD = 1;
}

PARSER_BEGIN(linkers)

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter; 

class linkers {

    // Tabla de errores
    static ArrayList<String> tabla = linkersTokenManager.tablaErrores;
    static Map<String, String> declaredVariables = new HashMap<String, String>();

    // Lista para almacenar el TAC generado
    static ArrayList<TAC> intermedia = new ArrayList<TAC>();
    static int tempVarCounter = 0; // contador de variables temporales actuales
    static int labelCounter = 0; // contador de etiquetas actuales

    public static void main(String[] args) {
        try {
            linkers link = new linkers(System.in);
            link.Programalink();

            if (!link.tabla.isEmpty()) {
                System.out.println("\u001B[31m\nErrores encontrados:\n\u001B[0m");
                for (String error : link.tabla) {
                    System.out.println(error);
                }
            } else {
                System.out.println("\u001B[32mAnálisis exitoso\u001B[0m");

                // Generar el archivo de codigo intermedio
                String outputFileName = "Intermedio.txt";
                PrintWriter writer = null;
                try {
                    writer = new PrintWriter(new FileWriter(outputFileName));
                    for (TAC i : intermedia) {
                        writer.println(i);
                    }
                    System.out.println("\nEl codigo intermedio generado ha sido guardado en el archivo: " + outputFileName);
                } catch (IOException e) {
                    System.out.println("Error al escribir el codigo intermedio en el archivo: " + e.getMessage());
                } finally {
                    if (writer != null) {
                        writer.close();
                    }
                }
            }

        } catch (ParseException e) {
            System.out.println("Error de Análisis -> " + e.getMessage());
        }
    }

    static void checkAndAddVariable(Token id, String type, int line, int column) {
        if (declaredVariables.containsKey(id.image)) {
            tabla.add("Error Semántico -> Variable repetida: " + id.image + " en línea " + line + ", columna " + column);
        } else {
            declaredVariables.put(id.image, type);
        }
    }

    // Clase para el objeto de representacion intermedia
    static class TAC {
        private String operator;
        private String operand1;
        private String operand2;
        private String result;

        // Constructor para operaciones binarias (+, -, *, /)
        public TAC(String operator, String operand1, String operand2, String result) {
            this.operator = operator;
            this.operand1 = operand1;
            this.operand2 = operand2;
            this.result = result;
        }

        // Constructor para operaciones de Asignacion 
        public TAC(String operator, String operand1, String result) {
            this(operator, operand1, null,result); // Se llama al primer constructor por una operacion unaria
        }

        // Constructor para operaciones de salto o etiquetado 
        public TAC(String operator, String result) {
            this(operator, null, null, result); // Operaciones sin operandos
        }

        // getters

        public String getOperator() {
            return this.operator;
        }

        public String getOperand1() {
            return this.operand1;
        }

        public String getOperand2() {
            return this.operand2;
        }

        public String getResult() {
            return this.result;
        }

        @Override
        public String toString() {
            if (this.operand2 != null) { // Es una operacion binaria
                return this.result + " = " + this.operand1 + " " + this.operator + " " + this.operand2;
            } else if (this.operand1 != null) { // Es una asignacion
                return this.result + " " + this.operator + " " + this.operand1;
            } else { // Operaciones unarias
                return this.operator + " " + this.result;
            }
        }
    }

    // Clase para representar el resultado de una expresión
    static class ExpressionResult {
        String type;
        String place;

        public ExpressionResult(String type, String place) {
            this.type = type;
            this.place = place;
        }
    }

    // Procedimiento para generar variables temporales 
    static String newTemp() {
        return "t" + (tempVarCounter++);
    }

    // Método para generar el etiquetado
    static String newLabel() {
        return "L" + (labelCounter++);
    }


}

PARSER_END(linkers)

TOKEN_MGR_DECLS : {
    static ArrayList<String> tablaErrores = new ArrayList<String>();

    public void LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {
        String errorMessage = "Error Léxico -> Línea: " + errorLine + ", Columna: " + errorColumn + ", Descripción: ";
        if (EOFSeen) {
            errorMessage += "<EOF> encontrado, pero esperaba más caracteres.";
        } else {
            errorMessage += "\"" + curChar + "\" encontrado, pero esperaba más caracteres.";
        }
        linkers.tabla.add(errorMessage); // Corregido para apuntar a 'tabla'
    }
}

TOKEN: {//PALABRAS RESERVADAS
    <ReservadaInicio: "INICIAR">
    | <Lectura: "Leer">
    | <Escritura: "Escribir">
    | <CondicionalIf: "if">
    | <CondicionalElse: "else"> // Asegúrate de incluir 'else' aquí
    | <CondicionalIfthen: "ifthen">
    | <CondicionalSwitch: "Switch">
    | <CicloWhile: "While">
    | <CicloFor: "For">
    | <Default: "Default">
    | <Caso: "Caso">
    | <Break: "Break">
    | <VERDADERO: "Verdadero">
    | <FALSO: "Falso">
}

TOKEN: {// TIPOS DE DATO
    <TipoDatoEntero: "Entero">
    | <TipoDatoDecimal: "Decimal">
    | <TipoDatoBooleano: "boolean">
    | <TipoDatoCadena: "Cadena">
    | <TIpoDatoCaracter: "Caracter">
}

TOKEN: { //CARACTERES
    <LlaveAbre: "{">
    | <LlaveCierra: "}">
    | <ParentesisAbre: "(">
    | <ParentesisCierra: ")">
    | <DelimitadorLineaDeCodigo: ";">
    | <DelimitadorCasoSwitch: ":">
}

TOKEN: {// OPERADORES ARITMETICOS
     <OperacionSuma: "+">
    | <OperacionResta: "-">
    | <OperacionMultiplicacion: "*">
    | <OperacionDivision: "/">
    | <OperacionResiduo: "%">
}

TOKEN: {// OPERADORES RELACIONALES
    <Asignacion: "=">
    | <OperacionMayorQue: ">">
    | <OperacionMenorQue: "<">
    | <OperacionMenorOIgualQue: "<=">
    | <OperacionMayorOIgualQue: ">=">
    | <OperacionIgualdad: "==">
    | <OperacionDesigualdad: "!=">
}

TOKEN: {// OPERADORES LOGICOS
    <OperacionAnd: "&">
    | <OperacionOr: "|">
    | <OperacionNot: "!">
}

TOKEN: {
    <CADENA: "\""(~["\""])*"\"">
    | <IDENTIFICADOR: (<LETRA>)+ (<LETRA>|<NUMERO>)* >
    | <NUMERO_FLOTANTE: (["0"-"9"])+"."(["0"-"9"])+>
    | <NUMERO: (["0"-"9"])+>
    | <LETRA: (["A"-"Z","a"-"z","á","é","í","ó","ú"])+>
}

SKIP: {
    " " | "\r" | "\t" | "\n" | "//"
}

SPECIAL_TOKEN: {
    < ANYTHING : ~[] > // Esto capturará cualquier token no definido
    {
        linkers.tabla.add("Error Léxico -> Línea: " + input_stream.getEndLine() + ", Columna: " + input_stream.getEndColumn() + ", Token no reconocido.");
    }
}

void Programalink() : {}{
    try {
        (
            try{<ReservadaInicio> }catch(ParseException e){tabla.add("Error de Sintaxis -> " + e.getMessage());}
            try{<LlaveAbre> }catch(ParseException e){tabla.add("Error de Sintaxis -> " + e.getMessage());}

            (sentencias())*

            try{<LlaveCierra> }catch(ParseException e){tabla.add("Error de Sintaxis -> " + e.getMessage());} )
    <EOF>
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != EOF);

        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

void sentencias() : {} {
    declararVariables()
    | asignacion()
    | entrada()
    | salida()
    | condicionalIf()
    | condicionalIfthen()
    | cicloFor()
    | cicloWhile()
}

void verificarExistenciaVariable(Token token) : {} {
    {
        if (!linkers.declaredVariables.containsKey(token.image)) {
            linkers.tabla.add("Error Semántico -> Variable no declarada: " + token.image + " en línea " + token.beginLine + ", columna " + token.beginColumn);
        }
    }
}

String verificarExistenciaYObtenerTipo(Token token) : {
    String tipo;
} {
    {
        if (token.kind == linkersConstants.IDENTIFICADOR) {
            if (linkers.declaredVariables.containsKey(token.image)) {
                tipo = linkers.declaredVariables.get(token.image);
            } else {
                linkers.tabla.add("Error Semántico -> Variable no declarada: " + token.image + " en línea " + token.beginLine + ", columna " + token.beginColumn);
                tipo = "error";
            }
        } else if (token.kind == linkersConstants.NUMERO) {
            tipo = "int";
        } else if (token.kind == linkersConstants.NUMERO_FLOTANTE) {
            tipo = "float";
        } else if (token.kind == linkersConstants.VERDADERO || token.kind == linkersConstants.FALSO) {
            tipo = "boolean";
        } else if (token.kind == linkersConstants.CADENA) {
            tipo = "string";
        } else if (token.kind == linkersConstants.LETRA) {
            tipo = "char";
        }
        else {
            tipo = "error";
        }
    }
    { return tipo; }
}

void declararVariables() : {} {
    VariableINT() | VariableFLOAT() | VariableBOOLEAN() | VariableCADENA() | VariableCARACTER()
}

void VariableINT() : {
    Token id;
    int line, column;
} {
    try {
        <TipoDatoEntero>
        id = <IDENTIFICADOR>
        {
            line = id.beginLine;
            column = id.beginColumn;
            linkers.checkAndAddVariable(id, "int", line, column);
        }
        [ <Asignacion> {
            ExpressionResult exprResult = expresion("int");
            // Generar TAC de asignación si hay inicialización
            String temp = linkers.newTemp();
            intermedia.add(new TAC("=", exprResult.place, temp));
            intermedia.add(new TAC("=", temp, id.image));
            // intermedia.add(new TAC("=", exprResult.place, id.image));
        } ]
        <DelimitadorLineaDeCodigo>
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != DelimitadorLineaDeCodigo);
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

void VariableFLOAT() : {
    Token id;
    int line, column;
} {
    try {
        <TipoDatoDecimal>
        id = <IDENTIFICADOR>
        {
            line = id.beginLine;
            column = id.beginColumn;
            linkers.checkAndAddVariable(id, "float", line, column);
        }
        [ <Asignacion> {
            ExpressionResult exprResult = expresion("float");
            // Generar tac de asignación si hay inicialización
            String temp = linkers.newTemp();
            intermedia.add(new TAC("=", exprResult.place, temp));
            intermedia.add(new TAC("=", temp, id.image));
            // intermedia.add(new TAC("=", exprResult.place, id.image));
        } ]
        <DelimitadorLineaDeCodigo>
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != DelimitadorLineaDeCodigo);
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

void VariableBOOLEAN() : {
    Token id;
    int line, column;
} {
    try {
        <TipoDatoBooleano>
        id = <IDENTIFICADOR>
        {
            line = id.beginLine;
            column = id.beginColumn;
            linkers.checkAndAddVariable(id, "boolean", line, column);
        }
        [ <Asignacion> {
            ExpressionResult exprResult = expresion("boolean");
            // Generar tac de asignación si hay inicialización
            String temp = linkers.newTemp();
            intermedia.add(new TAC("=", exprResult.place, temp));
            intermedia.add(new TAC("=", temp, id.image));
            // intermedia.add(new TAC("=", exprResult.place, id.image));
        } ]
        <DelimitadorLineaDeCodigo>
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != DelimitadorLineaDeCodigo);
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

void VariableCADENA() : {
    Token id;
    int line, column;
} {
    try {
        <TipoDatoCadena>
        id = <IDENTIFICADOR>
        {
            line = id.beginLine;
            column = id.beginColumn;
            linkers.checkAndAddVariable(id, "string", line, column);
        }
        [ <Asignacion> {
            ExpressionResult exprResult = expresion("string");
            // Generar TAC de asignación si hay inicialización
            String temp = linkers.newTemp();
            intermedia.add(new TAC("=", exprResult.place, temp));
            intermedia.add(new TAC("=", temp, id.image));
            // intermedia.add(new TAC("=", exprResult.place, id.image));
        } ]
        <DelimitadorLineaDeCodigo>
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != DelimitadorLineaDeCodigo);
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

void VariableCARACTER() : {
    Token id;
    int line, column;
} {
    try {
        <TIpoDatoCaracter>
        id = <IDENTIFICADOR>
        {
            line = id.beginLine;
            column = id.beginColumn;
            linkers.checkAndAddVariable(id, "char", line, column);
        }
        [ <Asignacion> {
            ExpressionResult exprResult = expresion("char");
            // Generar tac de asignación si hay inicialización
            String temp = linkers.newTemp();
            intermedia.add(new TAC("=", exprResult.place, temp));
            intermedia.add(new TAC("=", temp, id.image));
            // intermedia.add(new TAC("=", exprResult.place, id.image));
        } ]
        <DelimitadorLineaDeCodigo>
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != DelimitadorLineaDeCodigo);
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

void asignacion() : {
    Token id;
    String varType = "";
    ExpressionResult exprResult;
} {
    try {
        id = <IDENTIFICADOR>
        {
            if (!linkers.declaredVariables.containsKey(id.image)) {
                linkers.tabla.add("Error Semántico -> Variable no declarada: " + id.image + " en línea " + id.beginLine + ", columna " + id.beginColumn);
            } else {
                varType = linkers.declaredVariables.get(id.image);
            }
        }
        <Asignacion>
        {
            exprResult = expresion(varType);
            if (!exprResult.type.equals(varType)) {
                linkers.tabla.add("Error Semántico -> Tipo incorrecto en la operación. Se esperaba: " + varType + " pero se obtuvo: " + exprResult.type + " en línea " + id.beginLine + ", columna " + id.beginColumn);
            }
            // Generar TAC de asignación
            String temp = linkers.newTemp();
            intermedia.add(new TAC("=", exprResult.place, temp));
            intermedia.add(new TAC("=", temp, id.image));
            // intermedia.add(new TAC("=", exprResult.place, id.image));
        }
        <DelimitadorLineaDeCodigo>
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != DelimitadorLineaDeCodigo && t.kind != EOF);
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

void entrada() : {} {
    try {
        <Lectura>
        try {
            <ParentesisAbre>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }

        {
            Token token = jj_consume_token(linkersConstants.IDENTIFICADOR);
            if (!linkers.declaredVariables.containsKey(token.image)) {
                linkers.tabla.add("Error Semántico en entrada-> Variable no declarada: " + token.image + " en línea " + token.beginLine + ", columna " + token.beginColumn);
            } else {
                // Generar TAC de lectura
                intermedia.add(new TAC("Leer", token.image));
            }
        }
        try {
            <ParentesisCierra>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        try {
            <DelimitadorLineaDeCodigo>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != DelimitadorLineaDeCodigo);
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

void salida() : {
    ExpressionResult res;
} {
    try {
        <Escritura>
        try {
            <ParentesisAbre>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }

        {
            Token token = getToken(1);


            // Si solamente es una cadena, se escribe el mensaje
            if (token.kind == linkersConstants.CADENA) {
                jj_consume_token(linkersConstants.CADENA);
                // Generar cuadrupla de escritura
                intermedia.add(new TAC("Escribir", token.image));
            } else if (token.kind == linkersConstants.IDENTIFICADOR) {
                jj_consume_token(linkersConstants.IDENTIFICADOR);
                if (!linkers.declaredVariables.containsKey(token.image)) {
                    linkers.tabla.add("Error Semántico en salida-> Variable no declarada: " + token.image + " en línea " + token.beginLine + ", columna " + token.beginColumn);
                }
                intermedia.add(new TAC("Escribir", token.image)); 
            } else {
                linkers.tabla.add("Error de Sintaxis -> Se esperaba una cadena o un identificador, pero se encontró: " + token.image + " en línea " + token.beginLine + ", columna " + token.beginColumn);
                jj_consume_token(token.kind); // Consumir el token inesperado para continuar
            }
    
            // while (nextTokenIs(linkersConstants.OperacionSuma)) {
            //     jj_consume_token(linkersConstants.OperacionSuma);
            //     token = getToken(1);

            //     String temp = linkers.newTemp();
            //     String temp_ant = temp;
            //     if (token.kind == linkersConstants.CADENA) {
            //         jj_consume_token(linkersConstants.CADENA);
            //         intermedia.add(new TAC("=", "Escribir" + token.image, temp));
            //     } else if (token.kind == linkersConstants.IDENTIFICADOR) {
            //         jj_consume_token(linkersConstants.IDENTIFICADOR);
            //         if (!linkers.declaredVariables.containsKey(token.image)) {
            //             linkers.tabla.add("Error Semántico en salida-> Variable no declarada: " + token.image + " en línea " + token.beginLine + ", columna " + token.beginColumn);
            //         }
            //         intermedia.add(new TAC("+", token.image, temp));
            //         intermedia.add(new TAC("EScribir", temp));
            //     } else {
            //         linkers.tabla.add("Error de Sintaxis -> Se esperaba una cadena o un identificador, pero se encontró: " + token.image + " en línea " + token.beginLine + ", columna " + token.beginColumn);
            //         jj_consume_token(token.kind); // Consumir el token inesperado para continuar
            //     }
            // }
            boolean cadena = true;
            res = expresion("string");
            while (nextTokenIsOperadorAritmetico(cadena)) {
                // Generacion de codigo para la concatenaciones o sumas intermedias
                String op = operadorAritmetico();
                ExpressionResult right = expresion("string");
                String temp = linkers.newTemp();
                intermedia.add(new TAC(op, res.place, right.place, temp));
                res = new ExpressionResult("string", temp);
            }

            // Instruccion de salida
            intermedia.add(new TAC("Escribir", res.place));
        }
        try {
            <ParentesisCierra>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        try {
            <DelimitadorLineaDeCodigo>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != DelimitadorLineaDeCodigo && t.kind != EOF);
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

void condicionalIf() : {
    String condFalseLabel;
    String endLabel;
    ExpressionResult condResult;
} {
    try {
        <CondicionalIf>
        try {
            <ParentesisAbre>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        { condResult = condicion(); }
        try {
            <ParentesisCierra>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        {
            condFalseLabel = linkers.newLabel();
            endLabel = linkers.newLabel();
            // Generar salto condicional hacia else o fin
            intermedia.add(new TAC("ifFalse", condResult.place, "", condFalseLabel));
        }
        try {
            <LlaveAbre>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        (sentencias())*
        try {
            <LlaveCierra>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        {
            // Generar salto al fin después del bloque if
            intermedia.add(new TAC("goto", "", "", endLabel));
            // Etiqueta para el bloque else
            intermedia.add(new TAC("label", "", "", condFalseLabel));
        }
        // Manejar opcionalmente el bloque else
        (condicionalElseBlock())
        {
            // Etiqueta para el fin del bloque if-else
            intermedia.add(new TAC("label", "", "", endLabel));
        }
    } catch (ParseException e) {
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

// Método auxiliar para manejar el bloque else opcional
void condicionalElseBlock() : {} {
    try {
        (
            // Intentar consumir 'else'
            try {
                <CondicionalElse>
            } catch (ParseException e) {
                // No hay bloque else, regresar
                return;
            }
            try {
                <LlaveAbre>
            } catch (ParseException e) {
                tabla.add("Error de Sintaxis -> " + e.getMessage());
            }
            (sentencias())*
            try {
                <LlaveCierra>
            } catch (ParseException e) {
                tabla.add("Error de Sintaxis -> " + e.getMessage());
            }
        )
    } catch (ParseException e) {
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

void condicionalIfthen() : {
    String condFalseLabel;
    ExpressionResult condResult;
} {
    // Este método puede ser eliminado si no se utiliza o ajustado según las necesidades
    try {
        <CondicionalIfthen>
        try {
            <ParentesisAbre>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        { condResult = condicion(); }
        try {
            <ParentesisCierra>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        {
            condFalseLabel = linkers.newLabel();
            // Generar salto condicional
            intermedia.add(new TAC("ifFalse", condResult.place, "", condFalseLabel));
        }
        try {
            <LlaveAbre>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        (sentencias())*
        try {
            <LlaveCierra>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        {
            // Añadir etiqueta para el fin del bloque ifthen
            intermedia.add(new TAC("label", "", "", condFalseLabel));
        }
    } catch (ParseException e) {
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}



void cicloFor() : {
    String startLabel, endLabel;
    ExpressionResult condResult;
} {
    try {
        <CicloFor>
        try {
            <ParentesisAbre>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }

        (declararVariables() | asignacion())
        {
            startLabel = linkers.newLabel();
            intermedia.add(new TAC("label", "", "", startLabel));
        }
        { condResult = condicion(); }
        {
            endLabel = linkers.newLabel();
            // Generar salto condicional
            intermedia.add(new TAC("ifFalse", condResult.place, "", endLabel));
        }
        try {
            <DelimitadorLineaDeCodigo>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }

        { asignacion(); }
        try {
            <ParentesisCierra>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        try {
            <LlaveAbre>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }

        (sentencias())*
        {
            // Salto al inicio del ciclo
            intermedia.add(new TAC("goto", "", "", startLabel));
            // Etiqueta de fin del ciclo
            intermedia.add(new TAC("label", "", "", endLabel));
        }
        try {
            <LlaveCierra>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
    } catch (ParseException e) {
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

void cicloWhile() : {
    String startLabel, endLabel;
    ExpressionResult condResult;
} {
    try {
        <CicloWhile>
        {
            startLabel = linkers.newLabel();
            intermedia.add(new TAC("label", "", "", startLabel));
        }
        try {
            <ParentesisAbre>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        { condResult = condicion(); }
        {
            endLabel = linkers.newLabel();
            // Generar salto condicional
            intermedia.add(new TAC("ifFalse", condResult.place, "", endLabel));
        }
        try {
            <ParentesisCierra>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        try {
            <LlaveAbre>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        (sentencias())*
        {
            // Salto al inicio del ciclo
            intermedia.add(new TAC("goto", "", "", startLabel));
            // Etiqueta de fin del ciclo
            intermedia.add(new TAC("label", "", "", endLabel));
        }
        try {
            <LlaveCierra>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
    } catch (ParseException e) {
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

ExpressionResult condicion() : {
    ExpressionResult left, right;
    String op;
} {
    left = condicionSimple()
    (
        { if (nextTokenIsOperatorLogico()) { // Verificamos si viene un operador lógico
            op = operadorLogico();
            right = condicionSimple();
            String temp = linkers.newTemp();
            intermedia.add(new TAC(op, left.place, right.place, temp));
            left = new ExpressionResult("boolean", temp);
        }}
    ) // Eliminamos el * o + ya que no queremos repeticiones vacías
    { return left; }
}

ExpressionResult condicionSimple() : {
    Token token1, token2;
    String type1 = "", type2 = "";
    String op;
    ExpressionResult left, right;
} {
    {
        left = valor("any"); // Permitir cualquier tipo
        op = operadorRelacional();
        right = valor("any"); // Permitir cualquier tipo

        // Verificar que ambos operandos sean del mismo tipo o tipos compatibles
        if (!left.type.equals(right.type) && !left.type.equals("error") && !right.type.equals("error")) {
            tabla.add("Error Semántico en condición-> Tipos incompatibles en la condición: " + left.type + " y " + right.type);
        }

        // Generar una variable temporal para el resultado booleano
        String temp = linkers.newTemp();
        intermedia.add(new TAC(op, left.place, right.place, temp));

        return new ExpressionResult("boolean", temp);
    }
}

String operadorRelacional() : {
    Token opToken;
    String opStr;
} {
    (
        opToken = <OperacionMayorQue> { opStr = ">"; }
        | opToken = <OperacionMenorQue> { opStr = "<"; }
        | opToken = <OperacionMenorOIgualQue> { opStr = "<="; }
        | opToken = <OperacionMayorOIgualQue> { opStr = ">="; }
        | opToken = <OperacionIgualdad> { opStr = "=="; }
        | opToken = <OperacionDesigualdad> { opStr = "!="; }
    )
    { return opStr; }
}

String operadorLogico() : {
    Token opToken;
    String opStr;
} {
    (
        opToken = <OperacionAnd> { opStr = "&"; }
        | opToken = <OperacionOr> { opStr = "|"; }
        | opToken = <OperacionNot> { opStr = "!"; }
    )
    { return opStr; }
}

String operadorAritmetico() : {
    Token opToken;
    String opStr;
} {
    (
        opToken = <OperacionSuma> { opStr = "+"; }
        | opToken = <OperacionResta> { opStr = "-"; }
        | opToken = <OperacionMultiplicacion> { opStr = "*"; }
        | opToken = <OperacionDivision> { opStr = "/"; }
        | opToken = <OperacionResiduo> { opStr = "%"; }
    )
    { return opStr; }
}

ExpressionResult expresion(String expectedType) : {
    ExpressionResult left, right;
    String op;
} {
    left = termino(expectedType) 
    (
        { if (nextTokenIsOperadorAritmetico()) {  // Verifica si hay un operador aritmético
            op = operadorAritmetico();
            right = termino(expectedType);
            if (!left.type.equals(expectedType) || !right.type.equals(expectedType)) {
                tabla.add("Error Semántico -> Tipo incorrecto en la operación. Se esperaba: " + expectedType + " pero se obtuvo: " + left.type + " y " + right.type);
            }
            String temp = linkers.newTemp();
            intermedia.add(new TAC(op, left.place, right.place, temp));
            left = new ExpressionResult(expectedType, temp);
        }}
    )  // Elimina el * o + para evitar bucles vacíos
    { return left; }
}

ExpressionResult termino(String expectedType) : {
    ExpressionResult left, right;
    String op;
} {
    left = factor(expectedType)
    (
        { if (nextTokenIsOperadorAritmetico()) {  // Verifica si hay un operador aritmético
            op = operadorAritmetico();
            right = factor(expectedType);
            if (!left.type.equals(expectedType) || !right.type.equals(expectedType)) {
                tabla.add("Error Semántico -> Tipo incorrecto en la operación. Se esperaba: " + expectedType + " pero se obtuvo: " + left.type + " y " + right.type);
            }
            String temp = linkers.newTemp();
            intermedia.add(new TAC(op, left.place, right.place, temp));
            left = new ExpressionResult(expectedType, temp);
        }}
    )  // Elimina el * o + para evitar bucles vacíos
    { return left; }
}

ExpressionResult factor(String expectedType) : {
    Token token = null;
    String type = "";
    String place = "";
    ExpressionResult res = null; // Inicialización corregida
} {
    try {
        {if (nextTokenIs(linkersConstants.ParentesisAbre)) {
            res = operacionParentesis(expectedType);
            type = res.type;
            place = res.place;
        } else if (nextTokenIs(linkersConstants.NUMERO)) {
            token = jj_consume_token(linkersConstants.NUMERO);
            type = "int";
            place = token.image;
        } else if (nextTokenIs(linkersConstants.NUMERO_FLOTANTE)) {
            token = jj_consume_token(linkersConstants.NUMERO_FLOTANTE);
            type = "float";
            place = token.image;
        } else if (nextTokenIs(linkersConstants.VERDADERO)) {
            token = jj_consume_token(linkersConstants.VERDADERO);
            type = "boolean";
            place = "1";
        } else if (nextTokenIs(linkersConstants.FALSO)) {
            token = jj_consume_token(linkersConstants.FALSO);
            type = "boolean";
            place = "0";
        } else if(nextTokenIs(linkersConstants.CADENA)) {
            token = jj_consume_token(linkersConstants.CADENA);
            type = "string";
            place = token.image;
        } else if (nextTokenIs(linkersConstants.LETRA)) {
            token = jj_consume_token(linkersConstants.LETRA);
            type = "character";
            place = token.image;
        } else if (nextTokenIs(linkersConstants.IDENTIFICADOR)) {
            token = jj_consume_token(linkersConstants.IDENTIFICADOR);
            if (linkers.declaredVariables.containsKey(token.image)) {
                type = linkers.declaredVariables.get(token.image);
                place = token.image;
            } else {
                tabla.add("Error Semántico -> Variable no declarada: " + token.image + " en línea " + token.beginLine + ", columna " + token.beginColumn);
                type = "error";
            }
        } else {
            type = "error";
        }}

        // Verificar tipos si se espera uno específico
        {if (token != null && !"any".equals(expectedType) && !type.equals(expectedType) && !type.equals("error")) {
            tabla.add("Error Semántico -> Tipo incorrecto. Se esperaba: " + expectedType + " pero se obtuvo: " + type + " en línea " + token.beginLine + ", columna " + token.beginColumn);
        }}
    } catch (ParseException e) {
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
    {return (res != null) ? res : new ExpressionResult(type, place);}
}

boolean nextTokenIs(int kind) : {
    Token t;
} {
    {t = getToken(1);
    return t.kind == kind;}
}

// Métodos auxiliares para detectar operadores
boolean nextTokenIsOperatorLogico() : {
    Token t;
} {
    {t = getToken(1);
    return t.kind == linkersConstants.OperacionAnd || t.kind == linkersConstants.OperacionOr || t.kind == linkersConstants.OperacionNot;}
}

boolean nextTokenIsOperadorAritmetico() : {
    Token t;
} {
    {t = getToken(1);
    return t.kind == linkersConstants.OperacionSuma || t.kind == linkersConstants.OperacionResta || 
           t.kind == linkersConstants.OperacionMultiplicacion || t.kind == linkersConstants.OperacionDivision ||
           t.kind == linkersConstants.OperacionResiduo;}
}

boolean nextTokenIsOperadorAritmetico(boolean concat) : {
    Token t;
} {
    {t = getToken(1);
    return t.kind == linkersConstants.OperacionSuma || t.kind == linkersConstants.OperacionResta || 
           t.kind == linkersConstants.OperacionMultiplicacion || t.kind == linkersConstants.OperacionDivision ||
           t.kind == linkersConstants.OperacionResiduo;}
}

ExpressionResult operacionParentesis(String expectedType) : {
    ExpressionResult res=null;
} {
    try {
        {jj_consume_token(linkersConstants.ParentesisAbre);
        res = expresion(expectedType);
        jj_consume_token(linkersConstants.ParentesisCierra);

        if (!res.type.equals(expectedType)) {
            tabla.add("Error Semántico -> Tipo incorrecto en la operación entre paréntesis. Se esperaba: " + expectedType + " pero se obtuvo: " + res.type);
        }}
    } catch (ParseException e) {
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
    {return res;}
}

ExpressionResult valor(String expectedType) : {
    Token token = null;
    String type = "";
    String place = "";
} {
    try {
        {if (nextTokenIs(linkersConstants.NUMERO)) {
            token = jj_consume_token(linkersConstants.NUMERO);
            type = "int";
            place = token.image;
        } else if (nextTokenIs(linkersConstants.NUMERO_FLOTANTE)) {
            token = jj_consume_token(linkersConstants.NUMERO_FLOTANTE);
            type = "float";
            place = token.image;
        } else if (nextTokenIs(linkersConstants.VERDADERO)) {
            token = jj_consume_token(linkersConstants.VERDADERO);
            type = "boolean";
            place = "1";
        } else if (nextTokenIs(linkersConstants.FALSO)) {
            token = jj_consume_token(linkersConstants.FALSO);
            type = "boolean";
            place = "0";
        } else if(nextTokenIs(linkersConstants.CADENA)) {
            token = jj_consume_token(linkersConstants.CADENA);
            type = "string";
            place = token.image;
        } else if (nextTokenIs(linkersConstants.LETRA)) {
            token = jj_consume_token(linkersConstants.LETRA);
            type = "character";
            place = token.image;
        } else if (nextTokenIs(linkersConstants.IDENTIFICADOR)) {
            token = jj_consume_token(linkersConstants.IDENTIFICADOR);
            if (linkers.declaredVariables.containsKey(token.image)) {
                type = linkers.declaredVariables.get(token.image);
                place = token.image;
            } else {
                tabla.add("Error Semántico -> Variable no declarada: " + token.image + " en línea " + token.beginLine + ", columna " + token.beginColumn);
                type = "error";
            }
        } else {
            tabla.add("Error Semántico -> Token inesperado en la condición.");
            throw new ParseException("Token inesperado en la condición.");
        }}

        // Verificar tipos si se espera uno específico
        {if (token != null && !"any".equals(expectedType) && !type.equals(expectedType) && !type.equals("error")) {
            tabla.add("Error Semántico -> Tipo incorrecto. Se esperaba: " + expectedType + " pero se obtuvo: " + type + " en línea " + token.beginLine + ", columna " + token.beginColumn);
        }}
    } catch (ParseException e) {
        tabla.add("Error de Sintaxis -> " + e.getMessage());
        throw e;
    }
    {return new ExpressionResult(type, place);}
}

boolean tiposCompatibles(String type1, String type2) : { 
    boolean result = false;
} {
    {if (type1.equals("string") && (type2.equals("int") || type2.equals("float"))) {
        result = true;
    } else if ((type1.equals("int") || type1.equals("float")) && type2.equals("string")) {
        result = true;
    } else if (type2.equals("boolean") && type1.equals("string") || type1.equals("boolean") && type2.equals("string")) {
        result = true;
    } else if (type1.equals(type2)) {
        result = true; // Tipos iguales son compatibles
    }
    return result;
    }
}

ExpressionResult convertirACadena(ExpressionResult expr) : {} {
    {if (!expr.type.equals("string")) {
        // Se realiza una conversión implícita de tipos
        String temp = linkers.newTemp();
        intermedia.add(new TAC("toString", expr.place, temp));
        expr = new ExpressionResult("string", temp);
    }}
    {return expr;}
}
