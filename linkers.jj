options {
    LOOKAHEAD = 1;
}

PARSER_BEGIN(linkers)

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter; 

class linkers {

    // Tabla de errores
    static ArrayList<String> tabla = linkersTokenManager.tablaErrores;
    static Map<String, String> declaredVariables = new HashMap<String, String>();

    // Lista para almacenar el TAC generado
    static ArrayList<TAC> intermedia = new ArrayList<TAC>();
    static int tempVarCounter = 0; // contador de variables temporales actuales
    static int labelCounter = 0; // contador de etiquetas actuales

    public static void main(String[] args) {
        try {
            linkers link = new linkers(System.in);
            link.Programalink();

            if (!link.tabla.isEmpty()) {
                System.out.println("\u001B[31m\nErrores encontrados:\n\u001B[0m");
                for (String error : link.tabla) {
                    System.out.println(error);
                }
            } else {
                System.out.println("\u001B[32mAnálisis exitoso\u001B[0m");

                // Generar el archivo de codigo intermedio
                String outputFileName = "Intermedio.txt";
                PrintWriter writer = null;
                try {
                    writer = new PrintWriter(new FileWriter(outputFileName));
                    for (TAC i : intermedia) {
                        writer.println(i);
                    }
                    System.out.println("\nEl codigo intermedio generado ha sido guardado en el archivo: " + outputFileName);
                } catch (IOException e) {
                    System.out.println("Error al escribir el codigo intermedio en el archivo: " + e.getMessage());
                } finally {
                    if (writer != null) {
                        writer.close();
                    }
                }
            }

        } catch (ParseException e) {
            System.out.println("Error de Análisis -> " + e.getMessage());
        }
    }

    static void checkAndAddVariable(Token id, String type, int line, int column) {
        if (declaredVariables.containsKey(id.image)) {
            tabla.add("Error Semántico -> Variable repetida: " + id.image + " en línea " + line + ", columna " + column);
        } else {
            declaredVariables.put(id.image, type);
        }
    }

    // Clase para el objeto de representacion intermedia
    static class TAC {
        private String operator;
        private String operand1;
        private String operand2;
        private String result;

        public TAC() { }

        // Constructor para operaciones binarias (+, -, *, /)
        public TAC(String operator, String operand1, String operand2, String result) {
            this.operator = operator;
            this.operand1 = operand1;
            this.operand2 = operand2;
            this.result = result;
        }

        // Constructor para operaciones de Asignacion 
        public TAC(String operator, String operand1, String result) {
            this(operator, operand1, null,result); // Se llama al primer constructor por una operacion unaria
        }

        // Constructor para operaciones de salto o etiquetado 
        public TAC(String operator, String result) {
            this(operator, null, null, result); // Operaciones sin operandos
        }

        // getters

        public String getOperator() {
            return this.operator;
        }

        public String getOperand1() {
            return this.operand1;
        }

        public String getOperand2() {
            return this.operand2;
        }

        public String getResult() {
            return this.result;
        }

        @Override
        public String toString() {
            if (this.operand2 != null) { // Es una operacion binaria
                return this.result + " = " + this.operand1 + " " + this.operator + " " + this.operand2;
            } else if (this.operand1 != null) { 
                return this.result + " " + this.operator + " " + this.operand1;
            } else { // Operaciones unarias
                return this.operator + " " + this.result;
            }
        }
    }

    // Clase para representar el resultado de una expresión
    static class ExpressionResult {
        String type;
        String place;

        public ExpressionResult(String type, String place) {
            this.type = type;
            this.place = place;
        }
    }

    // Procedimiento para generar variables temporales 
    static String newTemp() {
        return "t" + (tempVarCounter++);
    }

    // Método para generar el etiquetado
    static String newLabel() {
        return "L" + (labelCounter++) + " : ";
    }

    static class Parameter {
        String type;
        String name;
    
        public Parameter(String type, String name) {
            this.type = type;
            this.name = name;
        }

        public Parameter() {

        }
    }

}

PARSER_END(linkers)

TOKEN_MGR_DECLS : {
    static ArrayList<String> tablaErrores = new ArrayList<String>();

    public void LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {
        String errorMessage = "Error Léxico -> Línea: " + errorLine + ", Columna: " + errorColumn + ", Descripción: ";
        if (EOFSeen) {
            errorMessage += "<EOF> encontrado, pero esperaba más caracteres.";
        } else {
            errorMessage += "\"" + curChar + "\" encontrado, pero esperaba más caracteres.";
        }
        linkers.tabla.add(errorMessage); // Corregido para apuntar a 'tabla'
    }
}

TOKEN: {//PALABRAS RESERVADAS
    <ReservadaInicio: "INICIAR">
    | <Lectura: "Leer">
    | <Escritura: "Escribir">
    | <CondicionalIf: "if">
    | <CondicionalElse: "else"> 
    | <CondicionalIfthen: "ifthen">
    | <CondicionalSwitch: "Switch">
    | <CicloWhile: "While">
    | <CicloFor: "For">
    | <Default: "Default">
    | <Caso: "Caso">
    | <Break: "Break">
    | <VERDADERO: "Verdadero">
    | <FALSO: "Falso">
    | <PUBLICO: "Publico">
    | <PRIVADO: "Privado">
    | <NoRetorno: "NoRetorno">
    | <Start: "Start">
    | <End: "End">
    | <Funcion: "Funcion">
    | <Retorno: "Retorno">
    | <LlamarFuncion: "call">
}

TOKEN: {// TIPOS DE DATO
    <TipoDatoEntero: "Entero">
    | <TipoDatoDecimal: "Decimal">
    | <TipoDatoBooleano: "boolean">
    | <TipoDatoCadena: "Cadena">
    | <TIpoDatoCaracter: "Caracter">
}

TOKEN: { //CARACTERES
    <LlaveAbre: "{">
    | <LlaveCierra: "}">
    | <ParentesisAbre: "(">
    | <ParentesisCierra: ")">
    | <DelimitadorLineaDeCodigo: ";">
    | <DelimitadorCasoSwitch: ":">
    | <CorcheteAbre: "[">
    | <CorcheteCierra: "]">
    | <Coma: ",">
}

TOKEN: {// OPERADORES ARITMETICOS
     <OperacionSuma: "+">
    | <OperacionResta: "-">
    | <OperacionMultiplicacion: "*">
    | <OperacionDivision: "/">
    | <OperacionResiduo: "%">
}

TOKEN: {// OPERADORES RELACIONALES
    <Asignacion: "=">
    | <OperacionMayorQue: ">">
    | <OperacionMenorQue: "<">
    | <OperacionMenorOIgualQue: "<=">
    | <OperacionMayorOIgualQue: ">=">
    | <OperacionIgualdad: "==">
    | <OperacionDesigualdad: "!=">
}

TOKEN: {// OPERADORES LOGICOS
    <OperacionAnd: "&">
    | <OperacionOr: "|">
    | <OperacionNot: "!">
}

TOKEN: {
    <CADENA: "\""(~["\""])*"\"">
    | <IDENTIFICADOR: (<LETRA>)+ (<LETRA>|<NUMERO>)* >
    | <NUMERO_FLOTANTE: (["0"-"9"])+"."(["0"-"9"])+>
    | <NUMERO: (["0"-"9"])+>
    | <LETRA: (["A"-"Z","a"-"z","á","é","í","ó","ú"])+>
}

SKIP: {
    " " | "\r" | "\t" | "\n" 
}

SPECIAL_TOKEN: {
    < ANYTHING : ~[] > // Esto capturará cualquier token no definido
    {
        linkers.tabla.add("Error Léxico -> Línea: " + input_stream.getEndLine() + ", Columna: " + input_stream.getEndColumn() + ", Token no reconocido.");
    }
}

void Programalink() : {}{
    try {
        (
            try{<ReservadaInicio> }catch(ParseException e){tabla.add("Error de Sintaxis -> " + e.getMessage());}
            try{<LlaveAbre> }catch(ParseException e){tabla.add("Error de Sintaxis -> " + e.getMessage());}

            (sentencias())*

            try{<LlaveCierra> }catch(ParseException e){tabla.add("Error de Sintaxis -> " + e.getMessage());} )

            (procedimiento())*

            (funcion())*
    <EOF>
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != EOF);

        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

void sentencias() : {} {
    declararVariables()
    | asignacion()
    | entrada()
    | salida()
    | condicionalIf()
    | condicionalIfthen()
    | cicloFor()
    | cicloWhile()
    | condicionalSwitch()
    | llamadaFuncion()
} 


void verificarExistenciaVariable(Token token) : {} {
    {
        if (!linkers.declaredVariables.containsKey(token.image)) {
            linkers.tabla.add("Error Semántico -> Variable no declarada: " + token.image + " en línea " + token.beginLine + ", columna " + token.beginColumn);
        }
    }
}

/**
 * Verifica la existencia de un token y obtiene su tipo.
 *
 * @param token El token que se va a verificar.
 * @return El tipo del token si existe, de lo contrario, un valor que indique que no existe.
 * @throws SomeException Si ocurre un error durante la verificación.
 */
String verificarExistenciaYObtenerTipo(Token token) : {
    String tipo;
} {
    {
        if (token.kind == linkersConstants.IDENTIFICADOR) {
            if (linkers.declaredVariables.containsKey(token.image)) {
                tipo = linkers.declaredVariables.get(token.image);
            } else {
                linkers.tabla.add("Error Semántico -> Variable no declarada: " + token.image + " en línea " + token.beginLine + ", columna " + token.beginColumn);
                tipo = "error";
            }
        } else if (token.kind == linkersConstants.NUMERO) {
            tipo = "int";
        } else if (token.kind == linkersConstants.NUMERO_FLOTANTE) {
            tipo = "float";
        } else if (token.kind == linkersConstants.VERDADERO || token.kind == linkersConstants.FALSO) {
            tipo = "boolean";
        } else if (token.kind == linkersConstants.CADENA) {
            tipo = "string";
        } else if (token.kind == linkersConstants.LETRA) {
            tipo = "char";
        }
        else {
            tipo = "error";
        }
    }
    { return tipo; }
}

void declararVariables() : {} {
    VariableINT() 
    | VariableFLOAT() 
    | VariableBOOLEAN() 
    | VariableCADENA() 
    | VariableCARACTER()
}

/**
 * Este método `VariableINT` se utiliza para definir una variable de tipo entero (INT).
 * 
 * Variables locales:
 * - `Token id`: Representa el identificador del token.
 * - `int line`: Almacena el número de línea donde se encuentra la variable.
 * - `int column`: Almacena el número de columna donde se encuentra la variable.
 * - `boolean control`: Bandera de control que inicialmente está establecida en falso.
 * 
 * Este método no tiene parámetros de entrada ni valores de retorno.
 */
void VariableINT() : {
    Token id;
    int line, column;
    boolean control = false;
} {
    try {
        <TipoDatoEntero>
        id = <IDENTIFICADOR>
        {
            line = id.beginLine;
            column = id.beginColumn;
        }
        (
            try {
                <CorcheteAbre> {
                    Token token = getNextToken();
                    if (token.kind == linkersConstants.NUMERO) {
                        control = true;
                        linkers.checkAndAddVariable(id, "int[]", line, column);
                        intermedia.add(new TAC("reserva", token.image, id.image));
                    } else {
                        tabla.add("Error Semántico -> Tamaño de arreglo inválido: " + token.image + " en línea " + token.beginLine + ", columna " + token.beginColumn);
                    }
                }
                <CorcheteCierra>
            } catch (ParseException e) {
                tabla.add("Error de Sintaxis -> " + e.getMessage());
            }
        )?
        {
            if (!control) {
                linkers.checkAndAddVariable(id, "int", line, column);
            }
        }
        [ <Asignacion> {
            ExpressionResult exprResult = expresion("int");
            // Generar TAC de asignación si hay inicialización
            String temp = linkers.newTemp();
            intermedia.add(new TAC("=", exprResult.place, temp));
            intermedia.add(new TAC("=", temp, id.image));
            // intermedia.add(new TAC("=", exprResult.place, id.image));
        } ]
        <DelimitadorLineaDeCodigo>
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != DelimitadorLineaDeCodigo);
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

/**
 * * Inicializa un token para contener el identificador de la variable, y variables para almacenar los números
 * de línea y columna donde se declara la variable. Además, incluye una variable de control booleana para
  * procesamiento adicional.
 * *
 *  * Variables Locales:
 * - Token id: Representa el token identificador para la variable de punto flotante.
 * -  * - int line: Almacena el número de línea donde se declara la variable.
 * - i * - int column: Almacena el número de columna donde se declara la variable.
 * - in * - boolean control: Una bandera de control utilizada para procesamiento o validación adicional.
 */
void VariableFLOAT() : {
    Token id;
    int line, column;
    boolean control = false;
} {
    try {
        <TipoDatoDecimal>
        id = <IDENTIFICADOR>
        {
            line = id.beginLine;
            column = id.beginColumn;
        }
        (
            try {
                <CorcheteAbre> {
                    Token token = getNextToken();
                    if (token.kind == linkersConstants.NUMERO) {
                        control = true;
                        linkers.checkAndAddVariable(id, "float[]", line, column);
                        intermedia.add(new TAC("reserva", token.image, id.image));
                    } else {
                        tabla.add("Error Semántico -> Tamaño de arreglo inválido: " + token.image + " en línea " + token.beginLine + ", columna " + token.beginColumn);
                    }
                }
                <CorcheteCierra>
            } catch (ParseException e) {
                tabla.add("Error de Sintaxis -> " + e.getMessage());
            }
        )?
        {
            if (!control) {
                linkers.checkAndAddVariable(id, "float", line, column);
            }
        }
        [ <Asignacion> {
            ExpressionResult exprResult = expresion("float");
            // Generar tac de asignación si hay inicialización
            String temp = linkers.newTemp();
            intermedia.add(new TAC("=", exprResult.place, temp));
            intermedia.add(new TAC("=", temp, id.image));
            // intermedia.add(new TAC("=", exprResult.place, id.image));
        } ]
        <DelimitadorLineaDeCodigo>
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != DelimitadorLineaDeCodigo);
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

/**
 * Método que maneja la declaración de variables de tipo BOOLEAN en el compilador.
 * 
 * Variables locales:
 * - Token id: Representa el identificador del token.
 * - int line: Almacena la línea del código fuente donde se encuentra la variable.
 * - int column: Almacena la columna del código fuente donde se encuentra la variable.
 * - boolean control: Bandera de control utilizada en el proceso de manejo de la variable.
 * 
 * Este método es parte del archivo de definiciones del compilador y se encarga de 
 * procesar y validar las declaraciones de variables de tipo BOOLEAN en el código fuente.
 */
void VariableBOOLEAN() : {
    Token id;
    int line, column;
    boolean control = false;
} {
    try {
        <TipoDatoBooleano>
        id = <IDENTIFICADOR>
        {
            line = id.beginLine;
            column = id.beginColumn;
        }
        (
            try {
                <CorcheteAbre> {
                    Token token = getNextToken();
                    if (token.kind == linkersConstants.NUMERO) {
                        control = true;
                        linkers.checkAndAddVariable(id, "boolean[]", line, column);
                        intermedia.add(new TAC("reserva", token.image, id.image));
                    } else {
                        tabla.add("Error Semántico -> Tamaño de arreglo inválido: " + token.image + " en línea " + token.beginLine + ", columna " + token.beginColumn);
                    }
                }
                <CorcheteCierra>
            } catch (ParseException e) {
                tabla.add("Error de Sintaxis -> " + e.getMessage());
            }
        )?
        {
            if (!control) {
                linkers.checkAndAddVariable(id, "boolean", line, column);
            }
        }
        [ <Asignacion> {
            ExpressionResult exprResult = expresion("boolean");
            // Generar tac de asignación si hay inicialización
            String temp = linkers.newTemp();
            intermedia.add(new TAC("=", exprResult.place, temp));
            intermedia.add(new TAC("=", temp, id.image));
            // intermedia.add(new TAC("=", exprResult.place, id.image));
        } ]
        <DelimitadorLineaDeCodigo>
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != DelimitadorLineaDeCodigo);
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

void VariableCADENA() : {
    Token id;
    int line, column;
    boolean control = false;
} {
    try {
        <TipoDatoCadena>
        id = <IDENTIFICADOR>
        {
            line = id.beginLine;
            column = id.beginColumn;
        }
        (
            try {
                <CorcheteAbre> {
                    Token token = getNextToken();
                    if (token.kind == linkersConstants.NUMERO) {
                        control = true;
                        linkers.checkAndAddVariable(id, "string[]", line, column);
                        intermedia.add(new TAC("reserva", token.image, id.image));
                    } else {
                        tabla.add("Error Semántico -> Tamaño de arreglo inválido: " + token.image + " en línea " + token.beginLine + ", columna " + token.beginColumn);
                    }
                }
                <CorcheteCierra>
            } catch (ParseException e) {
                tabla.add("Error de Sintaxis -> " + e.getMessage());
            }
        )?
        {
            if (!control) {
                linkers.checkAndAddVariable(id, "string", line, column);
            }
        }
        [ <Asignacion> {
            ExpressionResult exprResult = expresion("string");
            // Generar TAC de asignación si hay inicialización
            String temp = linkers.newTemp();
            intermedia.add(new TAC("=", exprResult.place, temp));
            intermedia.add(new TAC("=", temp, id.image));
            // intermedia.add(new TAC("=", exprResult.place, id.image));
        } ]
        <DelimitadorLineaDeCodigo>
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != DelimitadorLineaDeCodigo);
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

void VariableCARACTER() : {
    Token id;
    int line, column;
    boolean control = false;
} {
    try {
        <TIpoDatoCaracter>
        id = <IDENTIFICADOR>
        {
            line = id.beginLine;
            column = id.beginColumn;
        }
        (
            try {
                <CorcheteAbre> {
                    Token token = getNextToken();
                    if (token.kind == linkersConstants.NUMERO) {
                        control = true;
                        linkers.checkAndAddVariable(id, "char[]", line, column);
                        intermedia.add(new TAC("reserva", token.image, id.image));
                    } else {
                        tabla.add("Error Semántico -> Tamaño de arreglo inválido: " + token.image + " en línea " + token.beginLine + ", columna " + token.beginColumn);
                    }
                }
                <CorcheteCierra>
            } catch (ParseException e) {
                tabla.add("Error de Sintaxis -> " + e.getMessage());
            }
        )?
        {
            if (!control) {
                linkers.checkAndAddVariable(id, "char", line, column);
            }
        }
        [ <Asignacion> {
            ExpressionResult exprResult = expresion("char");
            // Generar tac de asignación si hay inicialización
            String temp = linkers.newTemp();
            intermedia.add(new TAC("=", exprResult.place, temp));
            intermedia.add(new TAC("=", temp, id.image));
            // intermedia.add(new TAC("=", exprResult.place, id.image));
        } ]
        <DelimitadorLineaDeCodigo>
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != DelimitadorLineaDeCodigo);
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

/**
 * Este método representa una regla de asignación en un compilador.
 * 
 * Variables locales:
 * - `id`: Un token que representa el identificador de la variable a la que se le asignará un valor.
 * - `varType`: Una cadena que almacena el tipo de la variable. Inicialmente está vacía.
 * - `exprResult`: Un objeto de tipo `ExpressionResult` que almacena el resultado de la expresión que se asignará a la variable.
 * 
 * La implementación de este método debe definir cómo se realiza la asignación de valores a las variables,
 * incluyendo la verificación de tipos y la evaluación de la expresión.
 */
void asignacion() : {
    Token id;
    String varType = "";
    ExpressionResult exprResult;
} {
    try {
        id = <IDENTIFICADOR>
        {
            if (!linkers.declaredVariables.containsKey(id.image)) {
                linkers.tabla.add("Error Semántico -> Variable no declarada: " + id.image + " en línea " + id.beginLine + ", columna " + id.beginColumn);
            } else {
                varType = linkers.declaredVariables.get(id.image);
            }
        }
        <Asignacion>
        {
            exprResult = expresion(varType);
            if (!exprResult.type.equals(varType)) {
                linkers.tabla.add("Error Semántico -> Tipo incorrecto en la operación. Se esperaba: " + varType + " pero se obtuvo: " + exprResult.type + " en línea " + id.beginLine + ", columna " + id.beginColumn);
            }
            // Generar TAC de asignación
            String temp = linkers.newTemp();
            intermedia.add(new TAC("=", exprResult.place, temp));
            intermedia.add(new TAC("=", temp, id.image));
            // intermedia.add(new TAC("=", exprResult.place, id.image));
        }
        <DelimitadorLineaDeCodigo>
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != DelimitadorLineaDeCodigo && t.kind != EOF);
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

void entrada() : {} {
    try {
        <Lectura>
        try {
            <ParentesisAbre>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }

        {
            /**
             * Este fragmento de código consume un token del analizador léxico (lexer) en un compilador.
             * 
             * - `jj_consume_token(linkersConstants.IDENTIFICADOR)`: Esta llamada al método `jj_consume_token` 
             *   consume el siguiente token de la secuencia de entrada si coincide con el tipo de token 
             *   especificado, en este caso `linkersConstants.IDENTIFICADOR`. 
             *   Si el token no coincide, se lanzará una excepción de error de sintaxis.
             * 
             * - `Token token`: La variable `token` almacena el token consumido, que puede ser utilizado 
             *   posteriormente en el análisis sintáctico o semántico.
             */
            Token token = jj_consume_token(linkersConstants.IDENTIFICADOR);
            if (!linkers.declaredVariables.containsKey(token.image)) {
                linkers.tabla.add("Error Semántico en entrada-> Variable no declarada: " + token.image + " en línea " + token.beginLine + ", columna " + token.beginColumn);
            } else {
                // Generar TAC de lectura
                intermedia.add(new TAC("Leer", token.image));
            }
        }
        try {
            <ParentesisCierra>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        try {
            <DelimitadorLineaDeCodigo>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != DelimitadorLineaDeCodigo);
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

/**
 * El método `salida` es un método que no recibe parámetros y devuelve un valor de tipo `void`.
 * 
 * Dentro del bloque de inicialización del método, se declaran dos variables locales:
 * - `res` de tipo `ExpressionResult`.
 * - `temporal` de tipo `TAC`, que se inicializa con una nueva instancia de `TAC`.
 * 
 * El método `salida` no tiene un cuerpo de implementación definido en el código proporcionado,
 * lo que sugiere que podría estar incompleto o que su funcionalidad se define en otra parte.
 * 
 */
void salida() : {
    ExpressionResult res;
    TAC temporal = new TAC();
} {
    try {
        <Escritura>
        try {
            <ParentesisAbre>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }

        {
            Token token = getToken(1);
            String temp = "";
            boolean isConcatenation = false;

            // Si unicamente tenemos una cadena, se mostrara directamente 
            if (token.kind == linkersConstants.CADENA) {
                jj_consume_token(linkersConstants.CADENA);
                temp = newTemp();
                temporal = new TAC("Escribir", token.image);
            } else if (token.kind == linkersConstants.IDENTIFICADOR) {
                // Si es un identificador, verificamos que exista y obtenemos su tipo
                String type = linkers.verificarExistenciaYObtenerTipo(token);
                if (!type.equals("error")) {
                    temp = newTemp();
                    temporal = new TAC("Escribir", token.image);
                }
            } else {
                tabla.add("Error Semántico -> Tipo incorrecto en operación de escritura. Se esperaba: Cadena o Identificador");
            }

            int cont = 0;
            String temp2 = "";
            while (nextTokenIs(linkersConstants.OperacionSuma)) {
                isConcatenation = true;
                if (cont == 0) {
                    intermedia.add(new TAC("=", temporal.getResult(), temp));
                } 
                jj_consume_token(linkersConstants.OperacionSuma);
                token = getToken(1);
                temp = (cont != 0) ? temp2: temp;
                temp2 = newTemp();
                if (token.kind == linkersConstants.CADENA) {
                    jj_consume_token(linkersConstants.CADENA);
                    intermedia.add(new TAC("+", temp, token.image, temp2));
                } else if (token.kind == linkersConstants.IDENTIFICADOR) {
                    jj_consume_token(linkersConstants.IDENTIFICADOR);
                    if (!linkers.declaredVariables.containsKey(token.image)) {
                        tabla.add("Error Semántico -> Variable no declarada: " + token.image + " en línea " + token.beginLine + ", columna " + token.beginColumn);
                    } else {
                        intermedia.add(new TAC("+", temp, token.image, temp2));
                    }
                } else {
                    tabla.add("Error Semántico -> Tipo incorrecto en operación de escritura. Se esperaba: Cadena o Identificador" + " en línea " + token.beginLine + ", columna " + token.beginColumn);
                    jj_consume_token(token.kind);
                }
                cont += 1;
            }   

            if (isConcatenation) {
                intermedia.add(new TAC("Escribir", temp2));
            } else {
                intermedia.add(temporal);
            }
        }
        try {
            <ParentesisCierra>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        try {
            <DelimitadorLineaDeCodigo>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != DelimitadorLineaDeCodigo && t.kind != EOF);
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

void condicionalIf() : {
    String condFalseLabel;
    String endLabel;
    ExpressionResult condResult;
} {
    try {
        <CondicionalIf>
        try {
            <ParentesisAbre>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        { 
            condResult = condicion(); 
            intermedia.add(new TAC("if", "t" + (tempVarCounter - 1) + " goto" + " L" + labelCounter));
        }
        try {
            <ParentesisCierra>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }

        {
            condFalseLabel = linkers.newLabel();
            endLabel = linkers.newLabel(); 
            // Generar salto condicional hacia else o fin
            intermedia.add(new TAC("ifFalse", condResult.place, condFalseLabel));
        }
        try {
            <LlaveAbre>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        (sentencias())*
        try {
            <LlaveCierra>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        {
            // Generar salto al fin después del bloque if
            intermedia.add(new TAC("goto", endLabel));
            // Etiqueta para el bloque else
            intermedia.add(new TAC("label", condFalseLabel));
        }
        // Manejar opcionalmente el bloque else
        (condicionalElseBlock())
        {
            // Etiqueta para el fin del bloque if-else
            intermedia.add(new TAC(endLabel, ""));
        }
    } catch (ParseException e) {
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

// Método auxiliar para manejar el bloque else opcional
void condicionalElseBlock() : {} {
    try {
        (
            // Intentar consumir 'else'
            try {
                <CondicionalElse>
            } catch (ParseException e) {
                // No hay bloque else, regresar
                return;
            }
            try {
                <LlaveAbre>
            } catch (ParseException e) {
                tabla.add("Error de Sintaxis -> " + e.getMessage());
            }
            (sentencias())*
            try {
                <LlaveCierra>
            } catch (ParseException e) {
                tabla.add("Error de Sintaxis -> " + e.getMessage());
            }
        )
    } catch (ParseException e) {
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

void condicionalIfthen() : {
    String condFalseLabel;
    ExpressionResult condResult;
} {
    // Este método puede ser eliminado si no se utiliza o ajustado según las necesidades
    try {
        <CondicionalIfthen>
        try {
            <ParentesisAbre>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        { condResult = condicion(); }
        try {
            <ParentesisCierra>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        {
            condFalseLabel = linkers.newLabel();
            // Generar salto condicional
            intermedia.add(new TAC("ifFalse", condResult.place, condFalseLabel));
        }
        try {
            <LlaveAbre>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        (sentencias())*
        try {
            <LlaveCierra>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        {
            // Añadir etiqueta para el fin del bloque ifthen
            intermedia.add(new TAC("label", condFalseLabel));
        }
    } catch (ParseException e) {
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}



void cicloFor() : {
    String startLabel, endLabel;
    ExpressionResult condResult;
} {
    try {
        <CicloFor>
        try {
            <ParentesisAbre>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }

        (declararVariables() | asignacion())
        {
            startLabel = linkers.newLabel();
            intermedia.add(new TAC("label", startLabel));
        }
        { condResult = condicion(); }
        {
            endLabel = linkers.newLabel();
            // Generar salto condicional
            intermedia.add(new TAC("ifFalse", condResult.place, endLabel));
        }
        try {
            <DelimitadorLineaDeCodigo>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }

        { asignacion(); }
        try {
            <ParentesisCierra>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        try {
            <LlaveAbre>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }

        (sentencias())*
        {
            // Salto al inicio del ciclo
            intermedia.add(new TAC("goto", startLabel));
            // Etiqueta de fin del ciclo
            intermedia.add(new TAC("label", endLabel));
        }
        try {
            <LlaveCierra>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
    } catch (ParseException e) {
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

void cicloWhile() : {
    String startLabel, endLabel;
    ExpressionResult condResult;
} {
    try {
        <CicloWhile>
        {
            startLabel = linkers.newLabel();
            intermedia.add(new TAC("label", startLabel));
        }
        try {
            <ParentesisAbre>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        { condResult = condicion(); }
        {
            endLabel = linkers.newLabel();
            // Generar salto condicional
            intermedia.add(new TAC("ifFalse", condResult.place, endLabel));
        }
        try {
            <ParentesisCierra>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        try {
            <LlaveAbre>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        (sentencias())*
        {
            // Salto al inicio del ciclo
            intermedia.add(new TAC("goto", startLabel));
            // Etiqueta de fin del ciclo
            intermedia.add(new TAC("label", endLabel));
        }
        try {
            <LlaveCierra>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
    } catch (ParseException e) {
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

void condicionalSwitch() : {
    Token id;
    ExpressionResult exprResult;
} {
    try {
        <CondicionalSwitch>
        <ParentesisAbre>
        id = <IDENTIFICADOR>
        <ParentesisCierra>
        <LlaveAbre>
        {
            if (!linkers.declaredVariables.containsKey(id.image)) {
                linkers.tabla.add("Error Semántico -> Variable no declarada: " + id.image + " en línea " + id.beginLine + ", columna " + id.beginColumn);
            }
        }
        (
            caso()
        )*
        (
            defaultCaso()
        )?
        <LlaveCierra>
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != LlaveCierra && t.kind != EOF);
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

void caso() : {
    Token caseValue, id;
} {
    <Caso>
    caseValue = <NUMERO>
    <DelimitadorCasoSwitch>
    {
        id = getToken(1);
        String label = linkers.newLabel();
        intermedia.add(new TAC("label", label));
        intermedia.add(new TAC("if", id.image + " == " + caseValue.image, "goto " + label));
    }
    (
        sentencias()
    )*
    <Break>
    <DelimitadorLineaDeCodigo>
}

void defaultCaso() : {
    String label = linkers.newLabel();
} {
    <Default>
    <DelimitadorCasoSwitch>
    {
        intermedia.add(new TAC("label", label));
    }
    (
        sentencias()
    )*
}

void procedimiento() : {
    Token id;
    String startLabel, endLabel;
    ArrayList<Parameter> parameters = new ArrayList<>();

} {
    try {
        <NoRetorno>
        id = <IDENTIFICADOR>
        <ParentesisAbre>
        {
            parameters = listaParametros();
        }
        <ParentesisCierra>
        <Start>
        {
            startLabel = linkers.newLabel();
            endLabel = linkers.newLabel();
            intermedia.add(new TAC("label", startLabel)); // Etiqueta de inicio del procedimiento
            // Agregar los parámetros a la tabla de variables declaradas
            for (Parameter param : parameters) {
                linkers.declaredVariables.put(param.name, param.type);
            }
        }
        (sentencias())+
        {
            intermedia.add(new TAC("goto", endLabel)); // Salto al final del procedimiento
            intermedia.add(new TAC("", endLabel)); // Etiqueta de fin del procedimiento
        }
        <End>
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != linkersConstants.LlaveCierra && t.kind != EOF);
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

ArrayList<Parameter> listaParametros() : {
    ArrayList<Parameter> parameters = new ArrayList<>();
    Parameter param;
} {
    (
        param = parametro()
        {
            parameters.add(param);
        }
        (
            <Coma>
            param = parametro()
            {
                parameters.add(param);
            }
        )*
    )?
    { return parameters; }
}

Parameter parametro() : {
    Token id;
    String type;
} {
    (
        <TipoDatoEntero> { type = "int"; }
        | <TipoDatoDecimal> { type = "float"; }
        | <TipoDatoBooleano> { type = "boolean"; }
        | <TipoDatoCadena> { type = "string"; }
        | <TIpoDatoCaracter> { type = "char"; }
    )
    id = <IDENTIFICADOR>
    
    { return new Parameter(id.image, type); }
}

void funcion() : {
    Token id;
    String startLabel, endLabel;
    ArrayList<Parameter> parameters = new ArrayList<>();
    String returnType = "";
} {
    try {
        (<PUBLICO> | <PRIVADO>)
        (
            <TipoDatoEntero> { returnType = "int"; }
            | <TipoDatoDecimal> { returnType = "float"; }
            | <TipoDatoCadena> { returnType = "string"; }
            | <TIpoDatoCaracter> { returnType = "char"; }
        )
        id = <IDENTIFICADOR>
        <ParentesisAbre>
        {
            parameters = listaParametros();
        }
        <ParentesisCierra>
        <Start>
        {
            startLabel = linkers.newLabel();
            endLabel = linkers.newLabel();
            intermedia.add(new TAC("label", startLabel)); // Etiqueta de inicio de la función
            // Agregar los parámetros a la tabla de variables declaradas
            for (Parameter param : parameters) {
                linkers.declaredVariables.put(param.name, param.type);
            }
        }
        (sentencias())*
        (retorno(returnType))?
        {
            intermedia.add(new TAC("goto", endLabel)); // Salto al final de la función
            intermedia.add(new TAC("label", endLabel)); // Etiqueta de fin de la función
        }
        <End>
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != linkersConstants.LlaveCierra && t.kind != EOF);
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

void retorno(String returnType) : {
    ExpressionResult exprResult;
} {
    try {
        <Retorno>
        {
            exprResult = expresion(returnType);
            if (!exprResult.type.equals(returnType)) {
                tabla.add("Error Semántico -> Tipo de retorno incorrecto. Se esperaba: " + returnType + " pero se obtuvo: " + exprResult.type);
            }
            // Generar TAC de retorno
            intermedia.add(new TAC("return", exprResult.place));
        }
        <DelimitadorLineaDeCodigo>
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != DelimitadorLineaDeCodigo && t.kind != EOF);
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

ExpressionResult llamadaFuncion() : {
    Token id;
    ArrayList<ExpressionResult> argumentos = new ArrayList<>();
    String funcName;
    String returnType = "";
} {
    try {
        <LlamarFuncion>
        id = <IDENTIFICADOR>
        <ParentesisAbre>
        {
            funcName = id.image;
            if (!linkers.declaredVariables.containsKey(funcName)) {
                linkers.tabla.add("Error Semántico -> Función no declarada: " + funcName + " en línea " + id.beginLine + ", columna " + id.beginColumn);
            } else {
                returnType = linkers.declaredVariables.get(funcName);
            }
        }  
        (argumentos = listaArgumentos())
    <ParentesisCierra>
    {
        // Generar TAC para la llamada a la función
        String temp = linkers.newTemp();
        intermedia.add(new TAC("call", funcName, temp));
        for (ExpressionResult arg : argumentos) {
            intermedia.add(new TAC("param", arg.place));
        }
        return new ExpressionResult(returnType, temp);
    }
    <DelimitadorLineaDeCodigo>
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != DelimitadorLineaDeCodigo && t.kind != EOF);
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

ArrayList<ExpressionResult> listaArgumentos() : {
    ArrayList<ExpressionResult> argumentos = new ArrayList<>();
    ExpressionResult arg;
} {
        arg = expresion("any")
        {
            argumentos.add(arg);
        }
        (
            <Coma>
            arg = expresion("any")
            {
                argumentos.add(arg);
            }
        )*

    { return argumentos; }
}

ExpressionResult condicion() : {
    ExpressionResult left, right;
    String op;
} {
    left = condicionSimple()
    (
        { if (nextTokenIsOperatorLogico()) { // Verificamos si viene un operador lógico
            op = operadorLogico();
            right = condicionSimple();
            String temp = linkers.newTemp();
            intermedia.add(new TAC(op, left.place, right.place, temp));
            left = new ExpressionResult("boolean", temp);
        }}
    ) // Eliminamos el * o + ya que no queremos repeticiones vacías
    { return left; }
}

ExpressionResult condicionSimple() : {
    Token token1, token2;
    String type1 = "", type2 = "";
    String op;
    ExpressionResult left, right;
} {
    {
        left = valor("any"); // Permitir cualquier tipo
        op = operadorRelacional();
        right = valor("any"); // Permitir cualquier tipo

        // Verificar que ambos operandos sean del mismo tipo o tipos compatibles
        if (!left.type.equals(right.type) && !left.type.equals("error") && !right.type.equals("error")) {
            tabla.add("Error Semántico en condición-> Tipos incompatibles en la condición: " + left.type + " y " + right.type);
        }

        // Generar una variable temporal para el resultado booleano
        String temp = linkers.newTemp();
        intermedia.add(new TAC(op, left.place, right.place, temp));

        return new ExpressionResult("boolean", temp);
    }
}

String operadorRelacional() : {
    Token opToken;
    String opStr;
} {
    (
        opToken = <OperacionMayorQue> { opStr = ">"; }
        | opToken = <OperacionMenorQue> { opStr = "<"; }
        | opToken = <OperacionMenorOIgualQue> { opStr = "<="; }
        | opToken = <OperacionMayorOIgualQue> { opStr = ">="; }
        | opToken = <OperacionIgualdad> { opStr = "=="; }
        | opToken = <OperacionDesigualdad> { opStr = "!="; }
    )
    { return opStr; }
}

String operadorLogico() : {
    Token opToken;
    String opStr;
} {
    (
        opToken = <OperacionAnd> { opStr = "&"; }
        | opToken = <OperacionOr> { opStr = "|"; }
        | opToken = <OperacionNot> { opStr = "!"; }
    )
    { return opStr; }
}

String operadorAritmetico() : {
    Token opToken;
    String opStr;
} {
    (
        opToken = <OperacionSuma> { opStr = "+"; }
        | opToken = <OperacionResta> { opStr = "-"; }
        | opToken = <OperacionMultiplicacion> { opStr = "*"; }
        | opToken = <OperacionDivision> { opStr = "/"; }
        | opToken = <OperacionResiduo> { opStr = "%"; }
    )
    { return opStr; }
}

ExpressionResult expresion(String expectedType) : {
    ExpressionResult left, right;
    String op;
} {
    left = termino(expectedType)
    (
        { if (nextTokenIsOperadorAritmetico()) {
            op = operadorAritmetico();
            right = termino(expectedType);

            // Verificar si la operación es válida según el tipo esperado
            if (op.equals("+") && (left.type.equals("string") || right.type.equals("string"))) {
                // Si es concatenación y alguno es cadena, convertimos ambos operandos a cadena
                if (!left.type.equals("string")) {
                    String tempLeft = linkers.newTemp();
                    intermedia.add(new TAC("toString", left.place, tempLeft));
                    left = new ExpressionResult("string", tempLeft);
                }
                if (!right.type.equals("string")) {
                    String tempRight = linkers.newTemp();
                    intermedia.add(new TAC("toString", right.place, tempRight));
                    right = new ExpressionResult("string", tempRight);
                }
            } 
            else if (!left.type.equals(right.type)) {
                // Si no son compatibles, generamos un error
                tabla.add("Error Semántico en expresión-> Tipos incompatibles: " + left.type + " y " + right.type);
            }

            // Generamos el código intermedio con una nueva variable temporal
            String temp = linkers.newTemp();
            intermedia.add(new TAC(op, left.place, right.place, temp));
            left = new ExpressionResult(expectedType, temp);
        }}
    ) // Eliminamos el * o + ya que no queremos repeticiones vacías
    { return left; }
}



ExpressionResult termino(String expectedType) : {
    ExpressionResult left, right;
    String op;
} {
    left = factor(expectedType) 
    (
        { if (nextTokenIsOperadorAritmetico()) {
            op = operadorAritmetico();
            right = factor(expectedType); // Procesamos el siguiente factor

            if (!left.type.equals(expectedType) || !right.type.equals(expectedType)) {
                // Si los tipos no coinciden con lo esperado, lanzamos un error
                tabla.add("Error Semántico -> Tipo incorrecto en operación. Se esperaba: " + expectedType);
            }

            // Generamos el código intermedio
            String temp = linkers.newTemp();
            intermedia.add(new TAC(op, left.place, right.place, temp));
            left = new ExpressionResult(expectedType, temp);
        }}
    ) // Eliminamos el * o + ya que no queremos repeticiones vacías
    { return left; }
}


ExpressionResult factor(String expectedType) : {
    Token token = null;
    String type = "";
    String place = "";
    ExpressionResult res = null; // Inicialización corregida
} {
    try {
        {if (nextTokenIs(linkersConstants.ParentesisAbre)) {
            res = operacionParentesis(expectedType);
            type = res.type;
            place = res.place;
        } else if (nextTokenIs(linkersConstants.NUMERO)) {
            token = jj_consume_token(linkersConstants.NUMERO);
            type = "int";
            place = token.image;
        } else if (nextTokenIs(linkersConstants.NUMERO_FLOTANTE)) {
            token = jj_consume_token(linkersConstants.NUMERO_FLOTANTE);
            type = "float";
            place = token.image;
        } else if (nextTokenIs(linkersConstants.VERDADERO)) {
            token = jj_consume_token(linkersConstants.VERDADERO);
            type = "boolean";
            place = "1";
        } else if (nextTokenIs(linkersConstants.FALSO)) {
            token = jj_consume_token(linkersConstants.FALSO);
            type = "boolean";
            place = "0";
        } else if(nextTokenIs(linkersConstants.CADENA)) {
            token = jj_consume_token(linkersConstants.CADENA);
            type = "string";
            place = token.image;
        } else if (nextTokenIs(linkersConstants.LETRA)) {
            token = jj_consume_token(linkersConstants.LETRA);
            type = "character";
            place = token.image;
        } else if (nextTokenIs(linkersConstants.IDENTIFICADOR)) {
            token = jj_consume_token(linkersConstants.IDENTIFICADOR);
            if (linkers.declaredVariables.containsKey(token.image)) {
                type = linkers.declaredVariables.get(token.image);
                place = token.image;
            } else {
                tabla.add("Error Semántico -> Variable no declarada: " + token.image + " en línea " + token.beginLine + ", columna " + token.beginColumn);
                type = "error";
            }
        } else if (nextTokenIs(linkersConstants.Funcion)) {
            res = llamadaFuncion();
            type = res.type;
            place = res.place;
        } else {
            type = "error";
        }}

        // Verificar tipos si se espera uno específico
        {if (token != null && !"any".equals(expectedType) && !type.equals(expectedType) && !type.equals("error")) {
            tabla.add("Error Semántico -> Tipo incorrecto. Se esperaba: " + expectedType + " pero se obtuvo: " + type + " en línea " + token.beginLine + ", columna " + token.beginColumn);
        }}
    } catch (ParseException e) {
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
    {return (res != null) ? res : new ExpressionResult(type, place);}
}

boolean nextTokenIs(int kind) : {
    Token t;
} {
    {t = getToken(1);
    return t.kind == kind;}
}

// Métodos auxiliares para detectar operadores
boolean nextTokenIsOperatorLogico() : {
    Token t;
} {
    {t = getToken(1);
    return t.kind == linkersConstants.OperacionAnd || t.kind == linkersConstants.OperacionOr || t.kind == linkersConstants.OperacionNot;}
}

boolean nextTokenIsOperadorAritmetico() : {
    Token t;
} {
    {t = getToken(1);
    return t.kind == linkersConstants.OperacionSuma || t.kind == linkersConstants.OperacionResta || 
           t.kind == linkersConstants.OperacionMultiplicacion || t.kind == linkersConstants.OperacionDivision ||
           t.kind == linkersConstants.OperacionResiduo;}
}

ExpressionResult operacionParentesis(String expectedType) : {
    ExpressionResult res=null;
} {
    try {
        {jj_consume_token(linkersConstants.ParentesisAbre);
        res = expresion(expectedType);
        jj_consume_token(linkersConstants.ParentesisCierra);

        if (!res.type.equals(expectedType)) {
            tabla.add("Error Semántico -> Tipo incorrecto en la operación entre paréntesis. Se esperaba: " + expectedType + " pero se obtuvo: " + res.type);
        }}
    } catch (ParseException e) {
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
    {return res;}
}

ExpressionResult valor(String expectedType) : {
    Token token = null;
    String type = "";
    String place = "";
} {
    try {
        {if (nextTokenIs(linkersConstants.NUMERO)) {
            token = jj_consume_token(linkersConstants.NUMERO);
            type = "int";
            place = token.image;
        } else if (nextTokenIs(linkersConstants.NUMERO_FLOTANTE)) {
            token = jj_consume_token(linkersConstants.NUMERO_FLOTANTE);
            type = "float";
            place = token.image;
        } else if (nextTokenIs(linkersConstants.VERDADERO)) {
            token = jj_consume_token(linkersConstants.VERDADERO);
            type = "boolean";
            place = "1";
        } else if (nextTokenIs(linkersConstants.FALSO)) {
            token = jj_consume_token(linkersConstants.FALSO);
            type = "boolean";
            place = "0";
        } else if(nextTokenIs(linkersConstants.CADENA)) {
            token = jj_consume_token(linkersConstants.CADENA);
            type = "string";
            place = token.image;
        } else if (nextTokenIs(linkersConstants.LETRA)) {
            token = jj_consume_token(linkersConstants.LETRA);
            type = "character";
            place = token.image;
        } else if (nextTokenIs(linkersConstants.IDENTIFICADOR)) {
            token = jj_consume_token(linkersConstants.IDENTIFICADOR);
            if (linkers.declaredVariables.containsKey(token.image)) {
                type = linkers.declaredVariables.get(token.image);
                place = token.image;
            } else {
                tabla.add("Error Semántico -> Variable no declarada: " + token.image + " en línea " + token.beginLine + ", columna " + token.beginColumn);
                type = "error";
            }
        } else {
            tabla.add("Error Semántico -> Token inesperado en la condición.");
            throw new ParseException("Token inesperado en la condición.");
        }}

        // Verificar tipos si se espera uno específico
        {if (token != null && !"any".equals(expectedType) && !type.equals(expectedType) && !type.equals("error")) {
            tabla.add("Error Semántico -> Tipo incorrecto. Se esperaba: " + expectedType + " pero se obtuvo: " + type + " en línea " + token.beginLine + ", columna " + token.beginColumn);
        }}
    } catch (ParseException e) {
        tabla.add("Error de Sintaxis -> " + e.getMessage());
        throw e;
    }
    {return new ExpressionResult(type, place);}
}

ExpressionResult concatenar() : {
    ExpressionResult left, right;
    String temp;
    Token token = null;
} {
    left = expresion("string")// Empezamos con una expresión inicial, esperando tipo cadena
    (
        {if (nextTokenIsOperadorAritmetico() && getToken(1).image.equals("+")) { // Concatenación con operador "+"
        jj_consume_token(linkersConstants.OperacionSuma); // Consumimos el "+" operador

        // Evaluamos el siguiente valor en la concatenación
        right = expresion("string");

        // Si los tipos no son compatibles, convertimos a cadena
        if (!left.type.equals("string")) {
            temp = linkers.newTemp();
            intermedia.add(new TAC("toString", left.place, temp)); // Conversión a cadena
            left = new ExpressionResult("string", temp);
        }
        if (!right.type.equals("string")) {
            temp = linkers.newTemp();
            intermedia.add(new TAC("toString", right.place, temp)); // Conversión a cadena
            right = new ExpressionResult("string", temp);
        }

        // Generamos una nueva variable temporal para la concatenación
        temp = linkers.newTemp();
        intermedia.add(new TAC("+", left.place, right.place, temp));
        left = new ExpressionResult("string", temp);
        }}
    )    
    { return left; }
}
